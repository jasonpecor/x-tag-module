{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 30376518b92b5725c445","webpack:///./src/index.js","webpack:///./src/custom-event.js","webpack:///./src/xtag.js","webpack:///./src/element.matches.polyfill.js","webpack:///./~/x-tag/dist/x-tag-core.js","webpack:///./src/mixin.js","webpack:///./src/pseudo.js","webpack:///./src/web-component.js"],"names":["default","CustomEvent","name","attach","condition","capture","customEvents","window","__XTAG__","Element","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","s","document","ownerDocument","querySelectorAll","i","length","item","Mixin","options","mixins","Pseudo","action","onAdd","onRemove","onCompiled","pseudos","WebComponent","tags","register"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;iDCtCSA,O;;;;;;;;;2CACAA,O;;;;;;;;;4CACAA,O;;;;;;;;;0CACAA,O;;;;;;;;;kDACAA,O;;;;;;;;;;;;;;;mBCFeC,W;;AAFxB;;;;;;AAEe,UAASA,WAAT,CAAqBC,IAArB,QAA4E;AAAA,yBAAhDC,MAAgD;AAAA,MAAhDA,MAAgD,+BAAvC,EAAuC;AAAA,4BAAnCC,SAAmC;AAAA,MAAnCA,SAAmC,kCAAvB,IAAuB;AAAA,0BAAjBC,OAAiB;AAAA,MAAjBA,OAAiB,gCAAP,IAAO;;AAC1F,MAAI,CAAC,eAAKC,YAAL,CAAkBJ,IAAlB,CAAL,EACC,eAAKI,YAAL,CAAkBJ,IAAlB,IAA0B,EAACC,cAAD,EAASC,oBAAT,EAAoBC,gBAApB,EAA1B;AACD,SAAOH,IAAP;AACA;;;;;;;;;;;;;ACND;;AACA;;;;;;mBAEgB,YAAY;AAC3B,MAAI,OAAOK,OAAOC,QAAd,KAA2B,WAA/B,EACCD,OAAOC,QAAP;AACD,SAAOD,OAAOC,QAAd;AACA,EAJe,E;;;;;;;;;;;;;;mBCHA,YAAY;AAC3B,MAAI,CAACC,QAAQC,SAAR,CAAkBC,OAAvB,EAAgC;AAC/BF,WAAQC,SAAR,CAAkBC,OAAlB,GACCF,QAAQC,SAAR,CAAkBE,eAAlB,IACAH,QAAQC,SAAR,CAAkBG,kBADlB,IAEAJ,QAAQC,SAAR,CAAkBI,iBAFlB,IAGAL,QAAQC,SAAR,CAAkBK,gBAHlB,IAIAN,QAAQC,SAAR,CAAkBM,qBAJlB,IAKA,UAAUC,CAAV,EAAa;AACT,QAAIN,UAAU,CAAC,KAAKO,QAAL,IAAiB,KAAKC,aAAvB,EAAsCC,gBAAtC,CAAuDH,CAAvD,CAAd;AAAA,QACII,IAAIV,QAAQW,MADhB;AAEA,WAAO,EAAED,CAAF,IAAO,CAAP,IAAYV,QAAQY,IAAR,CAAaF,CAAb,MAAoB,IAAvC,EAA6C,CAAE;AAC/C,WAAOA,IAAI,CAAC,CAAZ;AACH,IAXF;AAYA;AACD,EAfe,E;;;;;;;;ACAhB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,yBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,4BAA2B,MAAM;AACjC;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,GAAG;AACtD;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA,qBAAoB;;AAEpB;AACA,qBAAoB;;AAEpB;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,uCAAuC;AACjE;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,wBAAwB;AACjE;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,2CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,6BAA6B;AAC7E;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,uDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,yBAAyB;AACnE;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,8BAA6B;AAC7B;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,wCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,oDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,6BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,oDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,mCAAkC,sCAAsC,OAAO,0BAA0B,gBAAgB,gBAAgB,kBAAkB,oBAAoB,OAAO;AACtL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,0BAAyB,2CAA2C;;AAEpE;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,0BAAyB,2CAA2C;;AAEpE;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,MAAM;AACrB,iBAAgB,MAAM;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,gBAAe,MAAM;AACrB,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,sBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,gBAAe,MAAM;AACrB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,6BAA6B,yBAAyB,0BAA0B,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA0C,aAAa;AACvD,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAwC,uBAAuB;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,4BAA2B,wCAAwC;AACnE;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,4BAA2B,wCAAwC;AACnE;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,4BAA2B,wCAAwC;AACnE;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,0CAAyC,wBAAwB;AACjE;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC;;AAED;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,wBAAuB;AACvB,yBAAwB,aAAa,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA2B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAY;AACZ;AACA;AACA;AACA,iBAAgB;AAChB,kBAAiB;AACjB,oBAAmB;AACnB,oBAAmB;AACnB,qBAAoB;AACpB;AACA;AACA;AACA,sEAAqE,SAAS,EAAE;AAChF;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAqE;AACrE;AACA;;AAEA;AACA;AACA,wDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA,UAAS;AACT;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,yEAAwE;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA,eAAc;AACd;AACA,qBAAoB,kDAAkD;AACtE;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,qDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,8BAA6B,+BAA+B;AAC5D,2BAA0B,gBAAgB;AAC1C,MAAK;;AAEL;AACA;AACA;AACA;AACA,2BAA0B,mBAAmB;AAC7C,MAAK;;AAEL;AACA,6CAA4C,4BAA4B,EAAE;AAC1E;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA8E;AAC9E,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH,EAAC;;;;;;;;;;;;mBCvsJuBG,K;;AAFxB;;;;;;AAEe,UAASA,KAAT,CAAetB,IAAf,EAAmC;AAAA,MAAduB,OAAc,uEAAJ,EAAI;;AACjD,MAAI,CAAC,eAAKC,MAAL,CAAYxB,IAAZ,CAAL,EACC,eAAKwB,MAAL,CAAYxB,IAAZ,IAAoBuB,OAApB;AACD,SAAOvB,IAAP;AACA;;;;;;;;;;;;mBCJuByB,M;;AAFxB;;;;;;AAEe,UAASA,MAAT,CAAgBzB,IAAhB,QAAyF;AAAA,yBAAlE0B,MAAkE;AAAA,MAAlEA,MAAkE,+BAAzD,IAAyD;AAAA,wBAAnDC,KAAmD;AAAA,MAAnDA,KAAmD,8BAA3C,IAA2C;AAAA,2BAArCC,QAAqC;AAAA,MAArCA,QAAqC,iCAA1B,IAA0B;AAAA,6BAApBC,UAAoB;AAAA,MAApBA,UAAoB,mCAAP,IAAO;;AACvG,MAAI,CAAC,eAAKC,OAAL,CAAa9B,IAAb,CAAL,EACC,eAAK8B,OAAL,CAAa9B,IAAb,IAAqB,EAAC0B,cAAD,EAASC,YAAT,EAAgBC,kBAAhB,EAA0BC,sBAA1B,EAArB;AACD,SAAO7B,IAAP;AACA;;;;;;;;;;;;mBCJuB+B,Y;;AAFxB;;;;;;AAEe,UAASA,YAAT,CAAsB/B,IAAtB,EAA0C;AAAA,MAAduB,OAAc,uEAAJ,EAAI;;AACxD,SAAO,eAAKS,IAAL,CAAUhC,IAAV,KAAmB,eAAKiC,QAAL,CAAcjC,IAAd,EAAoBuB,OAApB,CAA1B;AACA","file":"x-tag-module.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"x-tag-module\"] = factory();\n\telse\n\t\troot[\"x-tag-module\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 30376518b92b5725c445","export { default as CustomEvent } from 'custom-event'\r\nexport { default as Mixin } from 'mixin'\r\nexport { default as Pseudo } from 'pseudo'\r\nexport { default as xtag } from 'xtag'\r\nexport { default} from 'web-component'\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import xtag from 'xtag'\r\n\r\nexport default function CustomEvent(name, {attach = [], condition = null, capture = null}) {\r\n\tif (!xtag.customEvents[name])\r\n\t\txtag.customEvents[name] = {attach, condition, capture}\r\n\treturn name\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-event.js","import 'element.matches.polyfill'\r\nimport xtag from 'x-tag/dist/x-tag-core'\r\n\r\nexport default (function () {\r\n\tif (typeof window.__XTAG__ === 'undefined')\r\n\t\twindow.__XTAG__ = xtag\r\n\treturn window.__XTAG__\r\n}())\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/xtag.js","export default (function () {\r\n\tif (!Element.prototype.matches) {\r\n\t\tElement.prototype.matches =\r\n\t\t\tElement.prototype.matchesSelector ||\r\n\t\t\tElement.prototype.mozMatchesSelector ||\r\n\t\t\tElement.prototype.msMatchesSelector ||\r\n\t\t\tElement.prototype.oMatchesSelector ||\r\n\t\t\tElement.prototype.webkitMatchesSelector ||\r\n\t\t\tfunction (s) {\r\n\t\t\t    var matches = (this.document || this.ownerDocument).querySelectorAll(s),\r\n\t\t\t        i = matches.length;\r\n\t\t\t    while (--i >= 0 && matches.item(i) !== this) {}\r\n\t\t\t    return i > -1;\r\n\t\t\t}\r\n\t}\r\n}())\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/element.matches.polyfill.js","// DOMTokenList polyfill for IE9\r\n(function () {\r\n\r\nif (typeof window.Element === \"undefined\" || \"classList\" in document.documentElement) return;\r\n\r\nvar prototype = Array.prototype,\r\n    indexOf = prototype.indexOf,\r\n    slice = prototype.slice,\r\n    push = prototype.push,\r\n    splice = prototype.splice,\r\n    join = prototype.join;\r\n\r\nfunction DOMTokenList(el) {\r\n  this._element = el;\r\n  if (el.className != this._classCache) {\r\n    this._classCache = el.className;\r\n\r\n    if (!this._classCache) return;\r\n\r\n      // The className needs to be trimmed and split on whitespace\r\n      // to retrieve a list of classes.\r\n      var classes = this._classCache.replace(/^\\s+|\\s+$/g,'').split(/\\s+/),\r\n        i;\r\n    for (i = 0; i < classes.length; i++) {\r\n      push.call(this, classes[i]);\r\n    }\r\n  }\r\n};\r\n\r\nfunction setToClassName(el, classes) {\r\n  el.className = classes.join(' ');\r\n}\r\n\r\nDOMTokenList.prototype = {\r\n  add: function(token) {\r\n    if(this.contains(token)) return;\r\n    push.call(this, token);\r\n    setToClassName(this._element, slice.call(this, 0));\r\n  },\r\n  contains: function(token) {\r\n    return indexOf.call(this, token) !== -1;\r\n  },\r\n  item: function(index) {\r\n    return this[index] || null;\r\n  },\r\n  remove: function(token) {\r\n    var i = indexOf.call(this, token);\r\n     if (i === -1) {\r\n       return;\r\n     }\r\n    splice.call(this, i, 1);\r\n    setToClassName(this._element, slice.call(this, 0));\r\n  },\r\n  toString: function() {\r\n    return join.call(this, ' ');\r\n  },\r\n  toggle: function(token) {\r\n    if (indexOf.call(this, token) === -1) {\r\n      this.add(token);\r\n    } else {\r\n      this.remove(token);\r\n    }\r\n  }\r\n};\r\n\r\nwindow.DOMTokenList = DOMTokenList;\r\n\r\nfunction defineElementGetter (obj, prop, getter) {\r\n  if (Object.defineProperty) {\r\n    Object.defineProperty(obj, prop,{\r\n      get : getter\r\n    })\r\n  } else {\r\n    obj.__defineGetter__(prop, getter);\r\n  }\r\n}\r\n\r\ndefineElementGetter(Element.prototype, 'classList', function () {\r\n  return new DOMTokenList(this);\r\n});\r\n\r\n})();\r\n\r\n\r\n/**\r\n * @license\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n// @version 0.7.20\r\n(function() {\r\n  window.WebComponents = window.WebComponents || {\r\n    flags: {}\r\n  };\r\n  var file = \"webcomponents-lite.js\";\r\n  var script = document.querySelector('script[src*=\"' + file + '\"]');\r\n  var flags = {};\r\n  if (!flags.noOpts) {\r\n    location.search.slice(1).split(\"&\").forEach(function(option) {\r\n      var parts = option.split(\"=\");\r\n      var match;\r\n      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {\r\n        flags[match[1]] = parts[1] || true;\r\n      }\r\n    });\r\n    if (script) {\r\n      for (var i = 0, a; a = script.attributes[i]; i++) {\r\n        if (a.name !== \"src\") {\r\n          flags[a.name] = a.value || true;\r\n        }\r\n      }\r\n    }\r\n    if (flags.log && flags.log.split) {\r\n      var parts = flags.log.split(\",\");\r\n      flags.log = {};\r\n      parts.forEach(function(f) {\r\n        flags.log[f] = true;\r\n      });\r\n    } else {\r\n      flags.log = {};\r\n    }\r\n  }\r\n  if (flags.register) {\r\n    window.CustomElements = window.CustomElements || {\r\n      flags: {}\r\n    };\r\n    window.CustomElements.flags.register = flags.register;\r\n  }\r\n  WebComponents.flags = flags;\r\n})();\r\n\r\n(function(scope) {\r\n  \"use strict\";\r\n  var hasWorkingUrl = false;\r\n  if (!scope.forceJURL) {\r\n    try {\r\n      var u = new URL(\"b\", \"http://a\");\r\n      u.pathname = \"c%20d\";\r\n      hasWorkingUrl = u.href === \"http://a/c%20d\";\r\n    } catch (e) {}\r\n  }\r\n  if (hasWorkingUrl) return;\r\n  var relative = Object.create(null);\r\n  relative[\"ftp\"] = 21;\r\n  relative[\"file\"] = 0;\r\n  relative[\"gopher\"] = 70;\r\n  relative[\"http\"] = 80;\r\n  relative[\"https\"] = 443;\r\n  relative[\"ws\"] = 80;\r\n  relative[\"wss\"] = 443;\r\n  var relativePathDotMapping = Object.create(null);\r\n  relativePathDotMapping[\"%2e\"] = \".\";\r\n  relativePathDotMapping[\".%2e\"] = \"..\";\r\n  relativePathDotMapping[\"%2e.\"] = \"..\";\r\n  relativePathDotMapping[\"%2e%2e\"] = \"..\";\r\n  function isRelativeScheme(scheme) {\r\n    return relative[scheme] !== undefined;\r\n  }\r\n  function invalid() {\r\n    clear.call(this);\r\n    this._isInvalid = true;\r\n  }\r\n  function IDNAToASCII(h) {\r\n    if (\"\" == h) {\r\n      invalid.call(this);\r\n    }\r\n    return h.toLowerCase();\r\n  }\r\n  function percentEscape(c) {\r\n    var unicode = c.charCodeAt(0);\r\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {\r\n      return c;\r\n    }\r\n    return encodeURIComponent(c);\r\n  }\r\n  function percentEscapeQuery(c) {\r\n    var unicode = c.charCodeAt(0);\r\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {\r\n      return c;\r\n    }\r\n    return encodeURIComponent(c);\r\n  }\r\n  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\r\n  function parse(input, stateOverride, base) {\r\n    function err(message) {\r\n      errors.push(message);\r\n    }\r\n    var state = stateOverride || \"scheme start\", cursor = 0, buffer = \"\", seenAt = false, seenBracket = false, errors = [];\r\n    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\r\n      var c = input[cursor];\r\n      switch (state) {\r\n       case \"scheme start\":\r\n        if (c && ALPHA.test(c)) {\r\n          buffer += c.toLowerCase();\r\n          state = \"scheme\";\r\n        } else if (!stateOverride) {\r\n          buffer = \"\";\r\n          state = \"no scheme\";\r\n          continue;\r\n        } else {\r\n          err(\"Invalid scheme.\");\r\n          break loop;\r\n        }\r\n        break;\r\n\r\n       case \"scheme\":\r\n        if (c && ALPHANUMERIC.test(c)) {\r\n          buffer += c.toLowerCase();\r\n        } else if (\":\" == c) {\r\n          this._scheme = buffer;\r\n          buffer = \"\";\r\n          if (stateOverride) {\r\n            break loop;\r\n          }\r\n          if (isRelativeScheme(this._scheme)) {\r\n            this._isRelative = true;\r\n          }\r\n          if (\"file\" == this._scheme) {\r\n            state = \"relative\";\r\n          } else if (this._isRelative && base && base._scheme == this._scheme) {\r\n            state = \"relative or authority\";\r\n          } else if (this._isRelative) {\r\n            state = \"authority first slash\";\r\n          } else {\r\n            state = \"scheme data\";\r\n          }\r\n        } else if (!stateOverride) {\r\n          buffer = \"\";\r\n          cursor = 0;\r\n          state = \"no scheme\";\r\n          continue;\r\n        } else if (EOF == c) {\r\n          break loop;\r\n        } else {\r\n          err(\"Code point not allowed in scheme: \" + c);\r\n          break loop;\r\n        }\r\n        break;\r\n\r\n       case \"scheme data\":\r\n        if (\"?\" == c) {\r\n          this._query = \"?\";\r\n          state = \"query\";\r\n        } else if (\"#\" == c) {\r\n          this._fragment = \"#\";\r\n          state = \"fragment\";\r\n        } else {\r\n          if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\r\n            this._schemeData += percentEscape(c);\r\n          }\r\n        }\r\n        break;\r\n\r\n       case \"no scheme\":\r\n        if (!base || !isRelativeScheme(base._scheme)) {\r\n          err(\"Missing scheme.\");\r\n          invalid.call(this);\r\n        } else {\r\n          state = \"relative\";\r\n          continue;\r\n        }\r\n        break;\r\n\r\n       case \"relative or authority\":\r\n        if (\"/\" == c && \"/\" == input[cursor + 1]) {\r\n          state = \"authority ignore slashes\";\r\n        } else {\r\n          err(\"Expected /, got: \" + c);\r\n          state = \"relative\";\r\n          continue;\r\n        }\r\n        break;\r\n\r\n       case \"relative\":\r\n        this._isRelative = true;\r\n        if (\"file\" != this._scheme) this._scheme = base._scheme;\r\n        if (EOF == c) {\r\n          this._host = base._host;\r\n          this._port = base._port;\r\n          this._path = base._path.slice();\r\n          this._query = base._query;\r\n          this._username = base._username;\r\n          this._password = base._password;\r\n          break loop;\r\n        } else if (\"/\" == c || \"\\\\\" == c) {\r\n          if (\"\\\\\" == c) err(\"\\\\ is an invalid code point.\");\r\n          state = \"relative slash\";\r\n        } else if (\"?\" == c) {\r\n          this._host = base._host;\r\n          this._port = base._port;\r\n          this._path = base._path.slice();\r\n          this._query = \"?\";\r\n          this._username = base._username;\r\n          this._password = base._password;\r\n          state = \"query\";\r\n        } else if (\"#\" == c) {\r\n          this._host = base._host;\r\n          this._port = base._port;\r\n          this._path = base._path.slice();\r\n          this._query = base._query;\r\n          this._fragment = \"#\";\r\n          this._username = base._username;\r\n          this._password = base._password;\r\n          state = \"fragment\";\r\n        } else {\r\n          var nextC = input[cursor + 1];\r\n          var nextNextC = input[cursor + 2];\r\n          if (\"file\" != this._scheme || !ALPHA.test(c) || nextC != \":\" && nextC != \"|\" || EOF != nextNextC && \"/\" != nextNextC && \"\\\\\" != nextNextC && \"?\" != nextNextC && \"#\" != nextNextC) {\r\n            this._host = base._host;\r\n            this._port = base._port;\r\n            this._username = base._username;\r\n            this._password = base._password;\r\n            this._path = base._path.slice();\r\n            this._path.pop();\r\n          }\r\n          state = \"relative path\";\r\n          continue;\r\n        }\r\n        break;\r\n\r\n       case \"relative slash\":\r\n        if (\"/\" == c || \"\\\\\" == c) {\r\n          if (\"\\\\\" == c) {\r\n            err(\"\\\\ is an invalid code point.\");\r\n          }\r\n          if (\"file\" == this._scheme) {\r\n            state = \"file host\";\r\n          } else {\r\n            state = \"authority ignore slashes\";\r\n          }\r\n        } else {\r\n          if (\"file\" != this._scheme) {\r\n            this._host = base._host;\r\n            this._port = base._port;\r\n            this._username = base._username;\r\n            this._password = base._password;\r\n          }\r\n          state = \"relative path\";\r\n          continue;\r\n        }\r\n        break;\r\n\r\n       case \"authority first slash\":\r\n        if (\"/\" == c) {\r\n          state = \"authority second slash\";\r\n        } else {\r\n          err(\"Expected '/', got: \" + c);\r\n          state = \"authority ignore slashes\";\r\n          continue;\r\n        }\r\n        break;\r\n\r\n       case \"authority second slash\":\r\n        state = \"authority ignore slashes\";\r\n        if (\"/\" != c) {\r\n          err(\"Expected '/', got: \" + c);\r\n          continue;\r\n        }\r\n        break;\r\n\r\n       case \"authority ignore slashes\":\r\n        if (\"/\" != c && \"\\\\\" != c) {\r\n          state = \"authority\";\r\n          continue;\r\n        } else {\r\n          err(\"Expected authority, got: \" + c);\r\n        }\r\n        break;\r\n\r\n       case \"authority\":\r\n        if (\"@\" == c) {\r\n          if (seenAt) {\r\n            err(\"@ already seen.\");\r\n            buffer += \"%40\";\r\n          }\r\n          seenAt = true;\r\n          for (var i = 0; i < buffer.length; i++) {\r\n            var cp = buffer[i];\r\n            if (\"\t\" == cp || \"\\n\" == cp || \"\\r\" == cp) {\r\n              err(\"Invalid whitespace in authority.\");\r\n              continue;\r\n            }\r\n            if (\":\" == cp && null === this._password) {\r\n              this._password = \"\";\r\n              continue;\r\n            }\r\n            var tempC = percentEscape(cp);\r\n            null !== this._password ? this._password += tempC : this._username += tempC;\r\n          }\r\n          buffer = \"\";\r\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\r\n          cursor -= buffer.length;\r\n          buffer = \"\";\r\n          state = \"host\";\r\n          continue;\r\n        } else {\r\n          buffer += c;\r\n        }\r\n        break;\r\n\r\n       case \"file host\":\r\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\r\n          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == \":\" || buffer[1] == \"|\")) {\r\n            state = \"relative path\";\r\n          } else if (buffer.length == 0) {\r\n            state = \"relative path start\";\r\n          } else {\r\n            this._host = IDNAToASCII.call(this, buffer);\r\n            buffer = \"\";\r\n            state = \"relative path start\";\r\n          }\r\n          continue;\r\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\r\n          err(\"Invalid whitespace in file host.\");\r\n        } else {\r\n          buffer += c;\r\n        }\r\n        break;\r\n\r\n       case \"host\":\r\n       case \"hostname\":\r\n        if (\":\" == c && !seenBracket) {\r\n          this._host = IDNAToASCII.call(this, buffer);\r\n          buffer = \"\";\r\n          state = \"port\";\r\n          if (\"hostname\" == stateOverride) {\r\n            break loop;\r\n          }\r\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\r\n          this._host = IDNAToASCII.call(this, buffer);\r\n          buffer = \"\";\r\n          state = \"relative path start\";\r\n          if (stateOverride) {\r\n            break loop;\r\n          }\r\n          continue;\r\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\r\n          if (\"[\" == c) {\r\n            seenBracket = true;\r\n          } else if (\"]\" == c) {\r\n            seenBracket = false;\r\n          }\r\n          buffer += c;\r\n        } else {\r\n          err(\"Invalid code point in host/hostname: \" + c);\r\n        }\r\n        break;\r\n\r\n       case \"port\":\r\n        if (/[0-9]/.test(c)) {\r\n          buffer += c;\r\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c || stateOverride) {\r\n          if (\"\" != buffer) {\r\n            var temp = parseInt(buffer, 10);\r\n            if (temp != relative[this._scheme]) {\r\n              this._port = temp + \"\";\r\n            }\r\n            buffer = \"\";\r\n          }\r\n          if (stateOverride) {\r\n            break loop;\r\n          }\r\n          state = \"relative path start\";\r\n          continue;\r\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\r\n          err(\"Invalid code point in port: \" + c);\r\n        } else {\r\n          invalid.call(this);\r\n        }\r\n        break;\r\n\r\n       case \"relative path start\":\r\n        if (\"\\\\\" == c) err(\"'\\\\' not allowed in path.\");\r\n        state = \"relative path\";\r\n        if (\"/\" != c && \"\\\\\" != c) {\r\n          continue;\r\n        }\r\n        break;\r\n\r\n       case \"relative path\":\r\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || !stateOverride && (\"?\" == c || \"#\" == c)) {\r\n          if (\"\\\\\" == c) {\r\n            err(\"\\\\ not allowed in relative path.\");\r\n          }\r\n          var tmp;\r\n          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\r\n            buffer = tmp;\r\n          }\r\n          if (\"..\" == buffer) {\r\n            this._path.pop();\r\n            if (\"/\" != c && \"\\\\\" != c) {\r\n              this._path.push(\"\");\r\n            }\r\n          } else if (\".\" == buffer && \"/\" != c && \"\\\\\" != c) {\r\n            this._path.push(\"\");\r\n          } else if (\".\" != buffer) {\r\n            if (\"file\" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == \"|\") {\r\n              buffer = buffer[0] + \":\";\r\n            }\r\n            this._path.push(buffer);\r\n          }\r\n          buffer = \"\";\r\n          if (\"?\" == c) {\r\n            this._query = \"?\";\r\n            state = \"query\";\r\n          } else if (\"#\" == c) {\r\n            this._fragment = \"#\";\r\n            state = \"fragment\";\r\n          }\r\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\r\n          buffer += percentEscape(c);\r\n        }\r\n        break;\r\n\r\n       case \"query\":\r\n        if (!stateOverride && \"#\" == c) {\r\n          this._fragment = \"#\";\r\n          state = \"fragment\";\r\n        } else if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\r\n          this._query += percentEscapeQuery(c);\r\n        }\r\n        break;\r\n\r\n       case \"fragment\":\r\n        if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\r\n          this._fragment += c;\r\n        }\r\n        break;\r\n      }\r\n      cursor++;\r\n    }\r\n  }\r\n  function clear() {\r\n    this._scheme = \"\";\r\n    this._schemeData = \"\";\r\n    this._username = \"\";\r\n    this._password = null;\r\n    this._host = \"\";\r\n    this._port = \"\";\r\n    this._path = [];\r\n    this._query = \"\";\r\n    this._fragment = \"\";\r\n    this._isInvalid = false;\r\n    this._isRelative = false;\r\n  }\r\n  function jURL(url, base) {\r\n    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\r\n    this._url = url;\r\n    clear.call(this);\r\n    var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, \"\");\r\n    parse.call(this, input, null, base);\r\n  }\r\n  jURL.prototype = {\r\n    toString: function() {\r\n      return this.href;\r\n    },\r\n    get href() {\r\n      if (this._isInvalid) return this._url;\r\n      var authority = \"\";\r\n      if (\"\" != this._username || null != this._password) {\r\n        authority = this._username + (null != this._password ? \":\" + this._password : \"\") + \"@\";\r\n      }\r\n      return this.protocol + (this._isRelative ? \"//\" + authority + this.host : \"\") + this.pathname + this._query + this._fragment;\r\n    },\r\n    set href(href) {\r\n      clear.call(this);\r\n      parse.call(this, href);\r\n    },\r\n    get protocol() {\r\n      return this._scheme + \":\";\r\n    },\r\n    set protocol(protocol) {\r\n      if (this._isInvalid) return;\r\n      parse.call(this, protocol + \":\", \"scheme start\");\r\n    },\r\n    get host() {\r\n      return this._isInvalid ? \"\" : this._port ? this._host + \":\" + this._port : this._host;\r\n    },\r\n    set host(host) {\r\n      if (this._isInvalid || !this._isRelative) return;\r\n      parse.call(this, host, \"host\");\r\n    },\r\n    get hostname() {\r\n      return this._host;\r\n    },\r\n    set hostname(hostname) {\r\n      if (this._isInvalid || !this._isRelative) return;\r\n      parse.call(this, hostname, \"hostname\");\r\n    },\r\n    get port() {\r\n      return this._port;\r\n    },\r\n    set port(port) {\r\n      if (this._isInvalid || !this._isRelative) return;\r\n      parse.call(this, port, \"port\");\r\n    },\r\n    get pathname() {\r\n      return this._isInvalid ? \"\" : this._isRelative ? \"/\" + this._path.join(\"/\") : this._schemeData;\r\n    },\r\n    set pathname(pathname) {\r\n      if (this._isInvalid || !this._isRelative) return;\r\n      this._path = [];\r\n      parse.call(this, pathname, \"relative path start\");\r\n    },\r\n    get search() {\r\n      return this._isInvalid || !this._query || \"?\" == this._query ? \"\" : this._query;\r\n    },\r\n    set search(search) {\r\n      if (this._isInvalid || !this._isRelative) return;\r\n      this._query = \"?\";\r\n      if (\"?\" == search[0]) search = search.slice(1);\r\n      parse.call(this, search, \"query\");\r\n    },\r\n    get hash() {\r\n      return this._isInvalid || !this._fragment || \"#\" == this._fragment ? \"\" : this._fragment;\r\n    },\r\n    set hash(hash) {\r\n      if (this._isInvalid) return;\r\n      this._fragment = \"#\";\r\n      if (\"#\" == hash[0]) hash = hash.slice(1);\r\n      parse.call(this, hash, \"fragment\");\r\n    },\r\n    get origin() {\r\n      var host;\r\n      if (this._isInvalid || !this._scheme) {\r\n        return \"\";\r\n      }\r\n      switch (this._scheme) {\r\n       case \"data\":\r\n       case \"file\":\r\n       case \"javascript\":\r\n       case \"mailto\":\r\n        return \"null\";\r\n      }\r\n      host = this.host;\r\n      if (!host) {\r\n        return \"\";\r\n      }\r\n      return this._scheme + \"://\" + host;\r\n    }\r\n  };\r\n  var OriginalURL = scope.URL;\r\n  if (OriginalURL) {\r\n    jURL.createObjectURL = function(blob) {\r\n      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\r\n    };\r\n    jURL.revokeObjectURL = function(url) {\r\n      OriginalURL.revokeObjectURL(url);\r\n    };\r\n  }\r\n  scope.URL = jURL;\r\n})(self);\r\n\r\nif (typeof WeakMap === \"undefined\") {\r\n  (function() {\r\n    var defineProperty = Object.defineProperty;\r\n    var counter = Date.now() % 1e9;\r\n    var WeakMap = function() {\r\n      this.name = \"__st\" + (Math.random() * 1e9 >>> 0) + (counter++ + \"__\");\r\n    };\r\n    WeakMap.prototype = {\r\n      set: function(key, value) {\r\n        var entry = key[this.name];\r\n        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {\r\n          value: [ key, value ],\r\n          writable: true\r\n        });\r\n        return this;\r\n      },\r\n      get: function(key) {\r\n        var entry;\r\n        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\r\n      },\r\n      \"delete\": function(key) {\r\n        var entry = key[this.name];\r\n        if (!entry || entry[0] !== key) return false;\r\n        entry[0] = entry[1] = undefined;\r\n        return true;\r\n      },\r\n      has: function(key) {\r\n        var entry = key[this.name];\r\n        if (!entry) return false;\r\n        return entry[0] === key;\r\n      }\r\n    };\r\n    window.WeakMap = WeakMap;\r\n  })();\r\n}\r\n\r\n(function(global) {\r\n  if (global.JsMutationObserver) {\r\n    return;\r\n  }\r\n  var registrationsTable = new WeakMap();\r\n  var setImmediate;\r\n  if (/Trident|Edge/.test(navigator.userAgent)) {\r\n    setImmediate = setTimeout;\r\n  } else if (window.setImmediate) {\r\n    setImmediate = window.setImmediate;\r\n  } else {\r\n    var setImmediateQueue = [];\r\n    var sentinel = String(Math.random());\r\n    window.addEventListener(\"message\", function(e) {\r\n      if (e.data === sentinel) {\r\n        var queue = setImmediateQueue;\r\n        setImmediateQueue = [];\r\n        queue.forEach(function(func) {\r\n          func();\r\n        });\r\n      }\r\n    });\r\n    setImmediate = function(func) {\r\n      setImmediateQueue.push(func);\r\n      window.postMessage(sentinel, \"*\");\r\n    };\r\n  }\r\n  var isScheduled = false;\r\n  var scheduledObservers = [];\r\n  function scheduleCallback(observer) {\r\n    scheduledObservers.push(observer);\r\n    if (!isScheduled) {\r\n      isScheduled = true;\r\n      setImmediate(dispatchCallbacks);\r\n    }\r\n  }\r\n  function wrapIfNeeded(node) {\r\n    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\r\n  }\r\n  function dispatchCallbacks() {\r\n    isScheduled = false;\r\n    var observers = scheduledObservers;\r\n    scheduledObservers = [];\r\n    observers.sort(function(o1, o2) {\r\n      return o1.uid_ - o2.uid_;\r\n    });\r\n    var anyNonEmpty = false;\r\n    observers.forEach(function(observer) {\r\n      var queue = observer.takeRecords();\r\n      removeTransientObserversFor(observer);\r\n      if (queue.length) {\r\n        observer.callback_(queue, observer);\r\n        anyNonEmpty = true;\r\n      }\r\n    });\r\n    if (anyNonEmpty) dispatchCallbacks();\r\n  }\r\n  function removeTransientObserversFor(observer) {\r\n    observer.nodes_.forEach(function(node) {\r\n      var registrations = registrationsTable.get(node);\r\n      if (!registrations) return;\r\n      registrations.forEach(function(registration) {\r\n        if (registration.observer === observer) registration.removeTransientObservers();\r\n      });\r\n    });\r\n  }\r\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\r\n    for (var node = target; node; node = node.parentNode) {\r\n      var registrations = registrationsTable.get(node);\r\n      if (registrations) {\r\n        for (var j = 0; j < registrations.length; j++) {\r\n          var registration = registrations[j];\r\n          var options = registration.options;\r\n          if (node !== target && !options.subtree) continue;\r\n          var record = callback(options);\r\n          if (record) registration.enqueue(record);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  var uidCounter = 0;\r\n  function JsMutationObserver(callback) {\r\n    this.callback_ = callback;\r\n    this.nodes_ = [];\r\n    this.records_ = [];\r\n    this.uid_ = ++uidCounter;\r\n  }\r\n  JsMutationObserver.prototype = {\r\n    observe: function(target, options) {\r\n      target = wrapIfNeeded(target);\r\n      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\r\n        throw new SyntaxError();\r\n      }\r\n      var registrations = registrationsTable.get(target);\r\n      if (!registrations) registrationsTable.set(target, registrations = []);\r\n      var registration;\r\n      for (var i = 0; i < registrations.length; i++) {\r\n        if (registrations[i].observer === this) {\r\n          registration = registrations[i];\r\n          registration.removeListeners();\r\n          registration.options = options;\r\n          break;\r\n        }\r\n      }\r\n      if (!registration) {\r\n        registration = new Registration(this, target, options);\r\n        registrations.push(registration);\r\n        this.nodes_.push(target);\r\n      }\r\n      registration.addListeners();\r\n    },\r\n    disconnect: function() {\r\n      this.nodes_.forEach(function(node) {\r\n        var registrations = registrationsTable.get(node);\r\n        for (var i = 0; i < registrations.length; i++) {\r\n          var registration = registrations[i];\r\n          if (registration.observer === this) {\r\n            registration.removeListeners();\r\n            registrations.splice(i, 1);\r\n            break;\r\n          }\r\n        }\r\n      }, this);\r\n      this.records_ = [];\r\n    },\r\n    takeRecords: function() {\r\n      var copyOfRecords = this.records_;\r\n      this.records_ = [];\r\n      return copyOfRecords;\r\n    }\r\n  };\r\n  function MutationRecord(type, target) {\r\n    this.type = type;\r\n    this.target = target;\r\n    this.addedNodes = [];\r\n    this.removedNodes = [];\r\n    this.previousSibling = null;\r\n    this.nextSibling = null;\r\n    this.attributeName = null;\r\n    this.attributeNamespace = null;\r\n    this.oldValue = null;\r\n  }\r\n  function copyMutationRecord(original) {\r\n    var record = new MutationRecord(original.type, original.target);\r\n    record.addedNodes = original.addedNodes.slice();\r\n    record.removedNodes = original.removedNodes.slice();\r\n    record.previousSibling = original.previousSibling;\r\n    record.nextSibling = original.nextSibling;\r\n    record.attributeName = original.attributeName;\r\n    record.attributeNamespace = original.attributeNamespace;\r\n    record.oldValue = original.oldValue;\r\n    return record;\r\n  }\r\n  var currentRecord, recordWithOldValue;\r\n  function getRecord(type, target) {\r\n    return currentRecord = new MutationRecord(type, target);\r\n  }\r\n  function getRecordWithOldValue(oldValue) {\r\n    if (recordWithOldValue) return recordWithOldValue;\r\n    recordWithOldValue = copyMutationRecord(currentRecord);\r\n    recordWithOldValue.oldValue = oldValue;\r\n    return recordWithOldValue;\r\n  }\r\n  function clearRecords() {\r\n    currentRecord = recordWithOldValue = undefined;\r\n  }\r\n  function recordRepresentsCurrentMutation(record) {\r\n    return record === recordWithOldValue || record === currentRecord;\r\n  }\r\n  function selectRecord(lastRecord, newRecord) {\r\n    if (lastRecord === newRecord) return lastRecord;\r\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\r\n    return null;\r\n  }\r\n  function Registration(observer, target, options) {\r\n    this.observer = observer;\r\n    this.target = target;\r\n    this.options = options;\r\n    this.transientObservedNodes = [];\r\n  }\r\n  Registration.prototype = {\r\n    enqueue: function(record) {\r\n      var records = this.observer.records_;\r\n      var length = records.length;\r\n      if (records.length > 0) {\r\n        var lastRecord = records[length - 1];\r\n        var recordToReplaceLast = selectRecord(lastRecord, record);\r\n        if (recordToReplaceLast) {\r\n          records[length - 1] = recordToReplaceLast;\r\n          return;\r\n        }\r\n      } else {\r\n        scheduleCallback(this.observer);\r\n      }\r\n      records[length] = record;\r\n    },\r\n    addListeners: function() {\r\n      this.addListeners_(this.target);\r\n    },\r\n    addListeners_: function(node) {\r\n      var options = this.options;\r\n      if (options.attributes) node.addEventListener(\"DOMAttrModified\", this, true);\r\n      if (options.characterData) node.addEventListener(\"DOMCharacterDataModified\", this, true);\r\n      if (options.childList) node.addEventListener(\"DOMNodeInserted\", this, true);\r\n      if (options.childList || options.subtree) node.addEventListener(\"DOMNodeRemoved\", this, true);\r\n    },\r\n    removeListeners: function() {\r\n      this.removeListeners_(this.target);\r\n    },\r\n    removeListeners_: function(node) {\r\n      var options = this.options;\r\n      if (options.attributes) node.removeEventListener(\"DOMAttrModified\", this, true);\r\n      if (options.characterData) node.removeEventListener(\"DOMCharacterDataModified\", this, true);\r\n      if (options.childList) node.removeEventListener(\"DOMNodeInserted\", this, true);\r\n      if (options.childList || options.subtree) node.removeEventListener(\"DOMNodeRemoved\", this, true);\r\n    },\r\n    addTransientObserver: function(node) {\r\n      if (node === this.target) return;\r\n      this.addListeners_(node);\r\n      this.transientObservedNodes.push(node);\r\n      var registrations = registrationsTable.get(node);\r\n      if (!registrations) registrationsTable.set(node, registrations = []);\r\n      registrations.push(this);\r\n    },\r\n    removeTransientObservers: function() {\r\n      var transientObservedNodes = this.transientObservedNodes;\r\n      this.transientObservedNodes = [];\r\n      transientObservedNodes.forEach(function(node) {\r\n        this.removeListeners_(node);\r\n        var registrations = registrationsTable.get(node);\r\n        for (var i = 0; i < registrations.length; i++) {\r\n          if (registrations[i] === this) {\r\n            registrations.splice(i, 1);\r\n            break;\r\n          }\r\n        }\r\n      }, this);\r\n    },\r\n    handleEvent: function(e) {\r\n      e.stopImmediatePropagation();\r\n      switch (e.type) {\r\n       case \"DOMAttrModified\":\r\n        var name = e.attrName;\r\n        var namespace = e.relatedNode.namespaceURI;\r\n        var target = e.target;\r\n        var record = new getRecord(\"attributes\", target);\r\n        record.attributeName = name;\r\n        record.attributeNamespace = namespace;\r\n        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\r\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\r\n          if (!options.attributes) return;\r\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\r\n            return;\r\n          }\r\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\r\n          return record;\r\n        });\r\n        break;\r\n\r\n       case \"DOMCharacterDataModified\":\r\n        var target = e.target;\r\n        var record = getRecord(\"characterData\", target);\r\n        var oldValue = e.prevValue;\r\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\r\n          if (!options.characterData) return;\r\n          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\r\n          return record;\r\n        });\r\n        break;\r\n\r\n       case \"DOMNodeRemoved\":\r\n        this.addTransientObserver(e.target);\r\n\r\n       case \"DOMNodeInserted\":\r\n        var changedNode = e.target;\r\n        var addedNodes, removedNodes;\r\n        if (e.type === \"DOMNodeInserted\") {\r\n          addedNodes = [ changedNode ];\r\n          removedNodes = [];\r\n        } else {\r\n          addedNodes = [];\r\n          removedNodes = [ changedNode ];\r\n        }\r\n        var previousSibling = changedNode.previousSibling;\r\n        var nextSibling = changedNode.nextSibling;\r\n        var record = getRecord(\"childList\", e.target.parentNode);\r\n        record.addedNodes = addedNodes;\r\n        record.removedNodes = removedNodes;\r\n        record.previousSibling = previousSibling;\r\n        record.nextSibling = nextSibling;\r\n        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\r\n          if (!options.childList) return;\r\n          return record;\r\n        });\r\n      }\r\n      clearRecords();\r\n    }\r\n  };\r\n  global.JsMutationObserver = JsMutationObserver;\r\n  if (!global.MutationObserver) {\r\n    global.MutationObserver = JsMutationObserver;\r\n    JsMutationObserver._isPolyfilled = true;\r\n  }\r\n})(self);\r\n\r\nif (typeof HTMLTemplateElement === \"undefined\") {\r\n  (function() {\r\n    var TEMPLATE_TAG = \"template\";\r\n    var contentDoc = document.implementation.createHTMLDocument(\"template\");\r\n    var canDecorate = true;\r\n    HTMLTemplateElement = function() {};\r\n    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\r\n    HTMLTemplateElement.decorate = function(template) {\r\n      if (template.content) {\r\n        return;\r\n      }\r\n      template.content = contentDoc.createDocumentFragment();\r\n      var child;\r\n      while (child = template.firstChild) {\r\n        template.content.appendChild(child);\r\n      }\r\n      if (canDecorate) {\r\n        try {\r\n          Object.defineProperty(template, \"innerHTML\", {\r\n            get: function() {\r\n              var o = \"\";\r\n              for (var e = this.content.firstChild; e; e = e.nextSibling) {\r\n                o += e.outerHTML || escapeData(e.data);\r\n              }\r\n              return o;\r\n            },\r\n            set: function(text) {\r\n              contentDoc.body.innerHTML = text;\r\n              HTMLTemplateElement.bootstrap(contentDoc);\r\n              while (this.content.firstChild) {\r\n                this.content.removeChild(this.content.firstChild);\r\n              }\r\n              while (contentDoc.body.firstChild) {\r\n                this.content.appendChild(contentDoc.body.firstChild);\r\n              }\r\n            },\r\n            configurable: true\r\n          });\r\n        } catch (err) {\r\n          canDecorate = false;\r\n        }\r\n      }\r\n      HTMLTemplateElement.bootstrap(template.content);\r\n    };\r\n    HTMLTemplateElement.bootstrap = function(doc) {\r\n      var templates = doc.querySelectorAll(TEMPLATE_TAG);\r\n      for (var i = 0, l = templates.length, t; i < l && (t = templates[i]); i++) {\r\n        HTMLTemplateElement.decorate(t);\r\n      }\r\n    };\r\n    document.addEventListener(\"DOMContentLoaded\", function() {\r\n      HTMLTemplateElement.bootstrap(document);\r\n    });\r\n    var createElement = document.createElement;\r\n    document.createElement = function() {\r\n      \"use strict\";\r\n      var el = createElement.apply(document, arguments);\r\n      if (el.localName == \"template\") {\r\n        HTMLTemplateElement.decorate(el);\r\n      }\r\n      return el;\r\n    };\r\n    var escapeDataRegExp = /[&\\u00A0<>]/g;\r\n    function escapeReplace(c) {\r\n      switch (c) {\r\n       case \"&\":\r\n        return \"&amp;\";\r\n\r\n       case \"<\":\r\n        return \"&lt;\";\r\n\r\n       case \">\":\r\n        return \"&gt;\";\r\n\r\n       case \"\":\r\n        return \"&nbsp;\";\r\n      }\r\n    }\r\n    function escapeData(s) {\r\n      return s.replace(escapeDataRegExp, escapeReplace);\r\n    }\r\n  })();\r\n}\r\n\r\n(function(scope) {\r\n  \"use strict\";\r\n  if (!window.performance) {\r\n    var start = Date.now();\r\n    window.performance = {\r\n      now: function() {\r\n        return Date.now() - start;\r\n      }\r\n    };\r\n  }\r\n  if (!window.requestAnimationFrame) {\r\n    window.requestAnimationFrame = function() {\r\n      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\r\n      return nativeRaf ? function(callback) {\r\n        return nativeRaf(function() {\r\n          callback(performance.now());\r\n        });\r\n      } : function(callback) {\r\n        return window.setTimeout(callback, 1e3 / 60);\r\n      };\r\n    }();\r\n  }\r\n  if (!window.cancelAnimationFrame) {\r\n    window.cancelAnimationFrame = function() {\r\n      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {\r\n        clearTimeout(id);\r\n      };\r\n    }();\r\n  }\r\n  var workingDefaultPrevented = function() {\r\n    var e = document.createEvent(\"Event\");\r\n    e.initEvent(\"foo\", true, true);\r\n    e.preventDefault();\r\n    return e.defaultPrevented;\r\n  }();\r\n  if (!workingDefaultPrevented) {\r\n    var origPreventDefault = Event.prototype.preventDefault;\r\n    Event.prototype.preventDefault = function() {\r\n      if (!this.cancelable) {\r\n        return;\r\n      }\r\n      origPreventDefault.call(this);\r\n      Object.defineProperty(this, \"defaultPrevented\", {\r\n        get: function() {\r\n          return true;\r\n        },\r\n        configurable: true\r\n      });\r\n    };\r\n  }\r\n  var isIE = /Trident/.test(navigator.userAgent);\r\n  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== \"function\") {\r\n    window.CustomEvent = function(inType, params) {\r\n      params = params || {};\r\n      var e = document.createEvent(\"CustomEvent\");\r\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\r\n      return e;\r\n    };\r\n    window.CustomEvent.prototype = window.Event.prototype;\r\n  }\r\n  if (!window.Event || isIE && typeof window.Event !== \"function\") {\r\n    var origEvent = window.Event;\r\n    window.Event = function(inType, params) {\r\n      params = params || {};\r\n      var e = document.createEvent(\"Event\");\r\n      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\r\n      return e;\r\n    };\r\n    window.Event.prototype = origEvent.prototype;\r\n  }\r\n})(window.WebComponents);\r\n\r\nwindow.HTMLImports = window.HTMLImports || {\r\n  flags: {}\r\n};\r\n\r\n(function(scope) {\r\n  var IMPORT_LINK_TYPE = \"import\";\r\n  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement(\"link\"));\r\n  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\r\n  var wrap = function(node) {\r\n    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\r\n  };\r\n  var rootDocument = wrap(document);\r\n  var currentScriptDescriptor = {\r\n    get: function() {\r\n      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== \"complete\" ? document.scripts[document.scripts.length - 1] : null);\r\n      return wrap(script);\r\n    },\r\n    configurable: true\r\n  };\r\n  Object.defineProperty(document, \"_currentScript\", currentScriptDescriptor);\r\n  Object.defineProperty(rootDocument, \"_currentScript\", currentScriptDescriptor);\r\n  var isIE = /Trident/.test(navigator.userAgent);\r\n  function whenReady(callback, doc) {\r\n    doc = doc || rootDocument;\r\n    whenDocumentReady(function() {\r\n      watchImportsLoad(callback, doc);\r\n    }, doc);\r\n  }\r\n  var requiredReadyState = isIE ? \"complete\" : \"interactive\";\r\n  var READY_EVENT = \"readystatechange\";\r\n  function isDocumentReady(doc) {\r\n    return doc.readyState === \"complete\" || doc.readyState === requiredReadyState;\r\n  }\r\n  function whenDocumentReady(callback, doc) {\r\n    if (!isDocumentReady(doc)) {\r\n      var checkReady = function() {\r\n        if (doc.readyState === \"complete\" || doc.readyState === requiredReadyState) {\r\n          doc.removeEventListener(READY_EVENT, checkReady);\r\n          whenDocumentReady(callback, doc);\r\n        }\r\n      };\r\n      doc.addEventListener(READY_EVENT, checkReady);\r\n    } else if (callback) {\r\n      callback();\r\n    }\r\n  }\r\n  function markTargetLoaded(event) {\r\n    event.target.__loaded = true;\r\n  }\r\n  function watchImportsLoad(callback, doc) {\r\n    var imports = doc.querySelectorAll(\"link[rel=import]\");\r\n    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\r\n    function checkDone() {\r\n      if (parsedCount == importCount && callback) {\r\n        callback({\r\n          allImports: imports,\r\n          loadedImports: newImports,\r\n          errorImports: errorImports\r\n        });\r\n      }\r\n    }\r\n    function loadedImport(e) {\r\n      markTargetLoaded(e);\r\n      newImports.push(this);\r\n      parsedCount++;\r\n      checkDone();\r\n    }\r\n    function errorLoadingImport(e) {\r\n      errorImports.push(this);\r\n      parsedCount++;\r\n      checkDone();\r\n    }\r\n    if (importCount) {\r\n      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {\r\n        if (isImportLoaded(imp)) {\r\n          newImports.push(this);\r\n          parsedCount++;\r\n          checkDone();\r\n        } else {\r\n          imp.addEventListener(\"load\", loadedImport);\r\n          imp.addEventListener(\"error\", errorLoadingImport);\r\n        }\r\n      }\r\n    } else {\r\n      checkDone();\r\n    }\r\n  }\r\n  function isImportLoaded(link) {\r\n    return useNative ? link.__loaded || link.import && link.import.readyState !== \"loading\" : link.__importParsed;\r\n  }\r\n  if (useNative) {\r\n    new MutationObserver(function(mxns) {\r\n      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {\r\n        if (m.addedNodes) {\r\n          handleImports(m.addedNodes);\r\n        }\r\n      }\r\n    }).observe(document.head, {\r\n      childList: true\r\n    });\r\n    function handleImports(nodes) {\r\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\r\n        if (isImport(n)) {\r\n          handleImport(n);\r\n        }\r\n      }\r\n    }\r\n    function isImport(element) {\r\n      return element.localName === \"link\" && element.rel === \"import\";\r\n    }\r\n    function handleImport(element) {\r\n      var loaded = element.import;\r\n      if (loaded) {\r\n        markTargetLoaded({\r\n          target: element\r\n        });\r\n      } else {\r\n        element.addEventListener(\"load\", markTargetLoaded);\r\n        element.addEventListener(\"error\", markTargetLoaded);\r\n      }\r\n    }\r\n    (function() {\r\n      if (document.readyState === \"loading\") {\r\n        var imports = document.querySelectorAll(\"link[rel=import]\");\r\n        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\r\n          handleImport(imp);\r\n        }\r\n      }\r\n    })();\r\n  }\r\n  whenReady(function(detail) {\r\n    window.HTMLImports.ready = true;\r\n    window.HTMLImports.readyTime = new Date().getTime();\r\n    var evt = rootDocument.createEvent(\"CustomEvent\");\r\n    evt.initCustomEvent(\"HTMLImportsLoaded\", true, true, detail);\r\n    rootDocument.dispatchEvent(evt);\r\n  });\r\n  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\r\n  scope.useNative = useNative;\r\n  scope.rootDocument = rootDocument;\r\n  scope.whenReady = whenReady;\r\n  scope.isIE = isIE;\r\n})(window.HTMLImports);\r\n\r\n(function(scope) {\r\n  var modules = [];\r\n  var addModule = function(module) {\r\n    modules.push(module);\r\n  };\r\n  var initializeModules = function() {\r\n    modules.forEach(function(module) {\r\n      module(scope);\r\n    });\r\n  };\r\n  scope.addModule = addModule;\r\n  scope.initializeModules = initializeModules;\r\n})(window.HTMLImports);\r\n\r\nwindow.HTMLImports.addModule(function(scope) {\r\n  var CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\r\n  var CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\r\n  var path = {\r\n    resolveUrlsInStyle: function(style, linkUrl) {\r\n      var doc = style.ownerDocument;\r\n      var resolver = doc.createElement(\"a\");\r\n      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\r\n      return style;\r\n    },\r\n    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\r\n      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\r\n      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\r\n      return r;\r\n    },\r\n    replaceUrls: function(text, urlObj, linkUrl, regexp) {\r\n      return text.replace(regexp, function(m, pre, url, post) {\r\n        var urlPath = url.replace(/[\"']/g, \"\");\r\n        if (linkUrl) {\r\n          urlPath = new URL(urlPath, linkUrl).href;\r\n        }\r\n        urlObj.href = urlPath;\r\n        urlPath = urlObj.href;\r\n        return pre + \"'\" + urlPath + \"'\" + post;\r\n      });\r\n    }\r\n  };\r\n  scope.path = path;\r\n});\r\n\r\nwindow.HTMLImports.addModule(function(scope) {\r\n  var xhr = {\r\n    async: true,\r\n    ok: function(request) {\r\n      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;\r\n    },\r\n    load: function(url, next, nextContext) {\r\n      var request = new XMLHttpRequest();\r\n      if (scope.flags.debug || scope.flags.bust) {\r\n        url += \"?\" + Math.random();\r\n      }\r\n      request.open(\"GET\", url, xhr.async);\r\n      request.addEventListener(\"readystatechange\", function(e) {\r\n        if (request.readyState === 4) {\r\n          var redirectedUrl = null;\r\n          try {\r\n            var locationHeader = request.getResponseHeader(\"Location\");\r\n            if (locationHeader) {\r\n              redirectedUrl = locationHeader.substr(0, 1) === \"/\" ? location.origin + locationHeader : locationHeader;\r\n            }\r\n          } catch (e) {\r\n            console.error(e.message);\r\n          }\r\n          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);\r\n        }\r\n      });\r\n      request.send();\r\n      return request;\r\n    },\r\n    loadDocument: function(url, next, nextContext) {\r\n      this.load(url, next, nextContext).responseType = \"document\";\r\n    }\r\n  };\r\n  scope.xhr = xhr;\r\n});\r\n\r\nwindow.HTMLImports.addModule(function(scope) {\r\n  var xhr = scope.xhr;\r\n  var flags = scope.flags;\r\n  var Loader = function(onLoad, onComplete) {\r\n    this.cache = {};\r\n    this.onload = onLoad;\r\n    this.oncomplete = onComplete;\r\n    this.inflight = 0;\r\n    this.pending = {};\r\n  };\r\n  Loader.prototype = {\r\n    addNodes: function(nodes) {\r\n      this.inflight += nodes.length;\r\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\r\n        this.require(n);\r\n      }\r\n      this.checkDone();\r\n    },\r\n    addNode: function(node) {\r\n      this.inflight++;\r\n      this.require(node);\r\n      this.checkDone();\r\n    },\r\n    require: function(elt) {\r\n      var url = elt.src || elt.href;\r\n      elt.__nodeUrl = url;\r\n      if (!this.dedupe(url, elt)) {\r\n        this.fetch(url, elt);\r\n      }\r\n    },\r\n    dedupe: function(url, elt) {\r\n      if (this.pending[url]) {\r\n        this.pending[url].push(elt);\r\n        return true;\r\n      }\r\n      var resource;\r\n      if (this.cache[url]) {\r\n        this.onload(url, elt, this.cache[url]);\r\n        this.tail();\r\n        return true;\r\n      }\r\n      this.pending[url] = [ elt ];\r\n      return false;\r\n    },\r\n    fetch: function(url, elt) {\r\n      flags.load && console.log(\"fetch\", url, elt);\r\n      if (!url) {\r\n        setTimeout(function() {\r\n          this.receive(url, elt, {\r\n            error: \"href must be specified\"\r\n          }, null);\r\n        }.bind(this), 0);\r\n      } else if (url.match(/^data:/)) {\r\n        var pieces = url.split(\",\");\r\n        var header = pieces[0];\r\n        var body = pieces[1];\r\n        if (header.indexOf(\";base64\") > -1) {\r\n          body = atob(body);\r\n        } else {\r\n          body = decodeURIComponent(body);\r\n        }\r\n        setTimeout(function() {\r\n          this.receive(url, elt, null, body);\r\n        }.bind(this), 0);\r\n      } else {\r\n        var receiveXhr = function(err, resource, redirectedUrl) {\r\n          this.receive(url, elt, err, resource, redirectedUrl);\r\n        }.bind(this);\r\n        xhr.load(url, receiveXhr);\r\n      }\r\n    },\r\n    receive: function(url, elt, err, resource, redirectedUrl) {\r\n      this.cache[url] = resource;\r\n      var $p = this.pending[url];\r\n      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\r\n        this.onload(url, p, resource, err, redirectedUrl);\r\n        this.tail();\r\n      }\r\n      this.pending[url] = null;\r\n    },\r\n    tail: function() {\r\n      --this.inflight;\r\n      this.checkDone();\r\n    },\r\n    checkDone: function() {\r\n      if (!this.inflight) {\r\n        this.oncomplete();\r\n      }\r\n    }\r\n  };\r\n  scope.Loader = Loader;\r\n});\r\n\r\nwindow.HTMLImports.addModule(function(scope) {\r\n  var Observer = function(addCallback) {\r\n    this.addCallback = addCallback;\r\n    this.mo = new MutationObserver(this.handler.bind(this));\r\n  };\r\n  Observer.prototype = {\r\n    handler: function(mutations) {\r\n      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {\r\n        if (m.type === \"childList\" && m.addedNodes.length) {\r\n          this.addedNodes(m.addedNodes);\r\n        }\r\n      }\r\n    },\r\n    addedNodes: function(nodes) {\r\n      if (this.addCallback) {\r\n        this.addCallback(nodes);\r\n      }\r\n      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {\r\n        if (n.children && n.children.length) {\r\n          this.addedNodes(n.children);\r\n        }\r\n      }\r\n    },\r\n    observe: function(root) {\r\n      this.mo.observe(root, {\r\n        childList: true,\r\n        subtree: true\r\n      });\r\n    }\r\n  };\r\n  scope.Observer = Observer;\r\n});\r\n\r\nwindow.HTMLImports.addModule(function(scope) {\r\n  var path = scope.path;\r\n  var rootDocument = scope.rootDocument;\r\n  var flags = scope.flags;\r\n  var isIE = scope.isIE;\r\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\r\n  var IMPORT_SELECTOR = \"link[rel=\" + IMPORT_LINK_TYPE + \"]\";\r\n  var importParser = {\r\n    documentSelectors: IMPORT_SELECTOR,\r\n    importsSelectors: [ IMPORT_SELECTOR, \"link[rel=stylesheet]:not([type])\", \"style:not([type])\", \"script:not([type])\", 'script[type=\"application/javascript\"]', 'script[type=\"text/javascript\"]' ].join(\",\"),\r\n    map: {\r\n      link: \"parseLink\",\r\n      script: \"parseScript\",\r\n      style: \"parseStyle\"\r\n    },\r\n    dynamicElements: [],\r\n    parseNext: function() {\r\n      var next = this.nextToParse();\r\n      if (next) {\r\n        this.parse(next);\r\n      }\r\n    },\r\n    parse: function(elt) {\r\n      if (this.isParsed(elt)) {\r\n        flags.parse && console.log(\"[%s] is already parsed\", elt.localName);\r\n        return;\r\n      }\r\n      var fn = this[this.map[elt.localName]];\r\n      if (fn) {\r\n        this.markParsing(elt);\r\n        fn.call(this, elt);\r\n      }\r\n    },\r\n    parseDynamic: function(elt, quiet) {\r\n      this.dynamicElements.push(elt);\r\n      if (!quiet) {\r\n        this.parseNext();\r\n      }\r\n    },\r\n    markParsing: function(elt) {\r\n      flags.parse && console.log(\"parsing\", elt);\r\n      this.parsingElement = elt;\r\n    },\r\n    markParsingComplete: function(elt) {\r\n      elt.__importParsed = true;\r\n      this.markDynamicParsingComplete(elt);\r\n      if (elt.__importElement) {\r\n        elt.__importElement.__importParsed = true;\r\n        this.markDynamicParsingComplete(elt.__importElement);\r\n      }\r\n      this.parsingElement = null;\r\n      flags.parse && console.log(\"completed\", elt);\r\n    },\r\n    markDynamicParsingComplete: function(elt) {\r\n      var i = this.dynamicElements.indexOf(elt);\r\n      if (i >= 0) {\r\n        this.dynamicElements.splice(i, 1);\r\n      }\r\n    },\r\n    parseImport: function(elt) {\r\n      elt.import = elt.__doc;\r\n      if (window.HTMLImports.__importsParsingHook) {\r\n        window.HTMLImports.__importsParsingHook(elt);\r\n      }\r\n      if (elt.import) {\r\n        elt.import.__importParsed = true;\r\n      }\r\n      this.markParsingComplete(elt);\r\n      if (elt.__resource && !elt.__error) {\r\n        elt.dispatchEvent(new CustomEvent(\"load\", {\r\n          bubbles: false\r\n        }));\r\n      } else {\r\n        elt.dispatchEvent(new CustomEvent(\"error\", {\r\n          bubbles: false\r\n        }));\r\n      }\r\n      if (elt.__pending) {\r\n        var fn;\r\n        while (elt.__pending.length) {\r\n          fn = elt.__pending.shift();\r\n          if (fn) {\r\n            fn({\r\n              target: elt\r\n            });\r\n          }\r\n        }\r\n      }\r\n      this.parseNext();\r\n    },\r\n    parseLink: function(linkElt) {\r\n      if (nodeIsImport(linkElt)) {\r\n        this.parseImport(linkElt);\r\n      } else {\r\n        linkElt.href = linkElt.href;\r\n        this.parseGeneric(linkElt);\r\n      }\r\n    },\r\n    parseStyle: function(elt) {\r\n      var src = elt;\r\n      elt = cloneStyle(elt);\r\n      src.__appliedElement = elt;\r\n      elt.__importElement = src;\r\n      this.parseGeneric(elt);\r\n    },\r\n    parseGeneric: function(elt) {\r\n      this.trackElement(elt);\r\n      this.addElementToDocument(elt);\r\n    },\r\n    rootImportForElement: function(elt) {\r\n      var n = elt;\r\n      while (n.ownerDocument.__importLink) {\r\n        n = n.ownerDocument.__importLink;\r\n      }\r\n      return n;\r\n    },\r\n    addElementToDocument: function(elt) {\r\n      var port = this.rootImportForElement(elt.__importElement || elt);\r\n      port.parentNode.insertBefore(elt, port);\r\n    },\r\n    trackElement: function(elt, callback) {\r\n      var self = this;\r\n      var done = function(e) {\r\n        elt.removeEventListener(\"load\", done);\r\n        elt.removeEventListener(\"error\", done);\r\n        if (callback) {\r\n          callback(e);\r\n        }\r\n        self.markParsingComplete(elt);\r\n        self.parseNext();\r\n      };\r\n      elt.addEventListener(\"load\", done);\r\n      elt.addEventListener(\"error\", done);\r\n      if (isIE && elt.localName === \"style\") {\r\n        var fakeLoad = false;\r\n        if (elt.textContent.indexOf(\"@import\") == -1) {\r\n          fakeLoad = true;\r\n        } else if (elt.sheet) {\r\n          fakeLoad = true;\r\n          var csr = elt.sheet.cssRules;\r\n          var len = csr ? csr.length : 0;\r\n          for (var i = 0, r; i < len && (r = csr[i]); i++) {\r\n            if (r.type === CSSRule.IMPORT_RULE) {\r\n              fakeLoad = fakeLoad && Boolean(r.styleSheet);\r\n            }\r\n          }\r\n        }\r\n        if (fakeLoad) {\r\n          setTimeout(function() {\r\n            elt.dispatchEvent(new CustomEvent(\"load\", {\r\n              bubbles: false\r\n            }));\r\n          });\r\n        }\r\n      }\r\n    },\r\n    parseScript: function(scriptElt) {\r\n      var script = document.createElement(\"script\");\r\n      script.__importElement = scriptElt;\r\n      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);\r\n      scope.currentScript = scriptElt;\r\n      this.trackElement(script, function(e) {\r\n        if (script.parentNode) {\r\n          script.parentNode.removeChild(script);\r\n        }\r\n        scope.currentScript = null;\r\n      });\r\n      this.addElementToDocument(script);\r\n    },\r\n    nextToParse: function() {\r\n      this._mayParse = [];\r\n      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());\r\n    },\r\n    nextToParseInDoc: function(doc, link) {\r\n      if (doc && this._mayParse.indexOf(doc) < 0) {\r\n        this._mayParse.push(doc);\r\n        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\r\n        for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {\r\n          if (!this.isParsed(n)) {\r\n            if (this.hasResource(n)) {\r\n              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\r\n            } else {\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return link;\r\n    },\r\n    nextToParseDynamic: function() {\r\n      return this.dynamicElements[0];\r\n    },\r\n    parseSelectorsForNode: function(node) {\r\n      var doc = node.ownerDocument || node;\r\n      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;\r\n    },\r\n    isParsed: function(node) {\r\n      return node.__importParsed;\r\n    },\r\n    needsDynamicParsing: function(elt) {\r\n      return this.dynamicElements.indexOf(elt) >= 0;\r\n    },\r\n    hasResource: function(node) {\r\n      if (nodeIsImport(node) && node.__doc === undefined) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n  };\r\n  function nodeIsImport(elt) {\r\n    return elt.localName === \"link\" && elt.rel === IMPORT_LINK_TYPE;\r\n  }\r\n  function generateScriptDataUrl(script) {\r\n    var scriptContent = generateScriptContent(script);\r\n    return \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(scriptContent);\r\n  }\r\n  function generateScriptContent(script) {\r\n    return script.textContent + generateSourceMapHint(script);\r\n  }\r\n  function generateSourceMapHint(script) {\r\n    var owner = script.ownerDocument;\r\n    owner.__importedScripts = owner.__importedScripts || 0;\r\n    var moniker = script.ownerDocument.baseURI;\r\n    var num = owner.__importedScripts ? \"-\" + owner.__importedScripts : \"\";\r\n    owner.__importedScripts++;\r\n    return \"\\n//# sourceURL=\" + moniker + num + \".js\\n\";\r\n  }\r\n  function cloneStyle(style) {\r\n    var clone = style.ownerDocument.createElement(\"style\");\r\n    clone.textContent = style.textContent;\r\n    path.resolveUrlsInStyle(clone);\r\n    return clone;\r\n  }\r\n  scope.parser = importParser;\r\n  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;\r\n});\r\n\r\nwindow.HTMLImports.addModule(function(scope) {\r\n  var flags = scope.flags;\r\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\r\n  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\r\n  var rootDocument = scope.rootDocument;\r\n  var Loader = scope.Loader;\r\n  var Observer = scope.Observer;\r\n  var parser = scope.parser;\r\n  var importer = {\r\n    documents: {},\r\n    documentPreloadSelectors: IMPORT_SELECTOR,\r\n    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(\",\"),\r\n    loadNode: function(node) {\r\n      importLoader.addNode(node);\r\n    },\r\n    loadSubtree: function(parent) {\r\n      var nodes = this.marshalNodes(parent);\r\n      importLoader.addNodes(nodes);\r\n    },\r\n    marshalNodes: function(parent) {\r\n      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\r\n    },\r\n    loadSelectorsForNode: function(node) {\r\n      var doc = node.ownerDocument || node;\r\n      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;\r\n    },\r\n    loaded: function(url, elt, resource, err, redirectedUrl) {\r\n      flags.load && console.log(\"loaded\", url, elt);\r\n      elt.__resource = resource;\r\n      elt.__error = err;\r\n      if (isImportLink(elt)) {\r\n        var doc = this.documents[url];\r\n        if (doc === undefined) {\r\n          doc = err ? null : makeDocument(resource, redirectedUrl || url);\r\n          if (doc) {\r\n            doc.__importLink = elt;\r\n            this.bootDocument(doc);\r\n          }\r\n          this.documents[url] = doc;\r\n        }\r\n        elt.__doc = doc;\r\n      }\r\n      parser.parseNext();\r\n    },\r\n    bootDocument: function(doc) {\r\n      this.loadSubtree(doc);\r\n      this.observer.observe(doc);\r\n      parser.parseNext();\r\n    },\r\n    loadedAll: function() {\r\n      parser.parseNext();\r\n    }\r\n  };\r\n  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));\r\n  importer.observer = new Observer();\r\n  function isImportLink(elt) {\r\n    return isLinkRel(elt, IMPORT_LINK_TYPE);\r\n  }\r\n  function isLinkRel(elt, rel) {\r\n    return elt.localName === \"link\" && elt.getAttribute(\"rel\") === rel;\r\n  }\r\n  function hasBaseURIAccessor(doc) {\r\n    return !!Object.getOwnPropertyDescriptor(doc, \"baseURI\");\r\n  }\r\n  function makeDocument(resource, url) {\r\n    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\r\n    doc._URL = url;\r\n    var base = doc.createElement(\"base\");\r\n    base.setAttribute(\"href\", url);\r\n    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\r\n      Object.defineProperty(doc, \"baseURI\", {\r\n        value: url\r\n      });\r\n    }\r\n    var meta = doc.createElement(\"meta\");\r\n    meta.setAttribute(\"charset\", \"utf-8\");\r\n    doc.head.appendChild(meta);\r\n    doc.head.appendChild(base);\r\n    doc.body.innerHTML = resource;\r\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\r\n      HTMLTemplateElement.bootstrap(doc);\r\n    }\r\n    return doc;\r\n  }\r\n  if (!document.baseURI) {\r\n    var baseURIDescriptor = {\r\n      get: function() {\r\n        var base = document.querySelector(\"base\");\r\n        return base ? base.href : window.location.href;\r\n      },\r\n      configurable: true\r\n    };\r\n    Object.defineProperty(document, \"baseURI\", baseURIDescriptor);\r\n    Object.defineProperty(rootDocument, \"baseURI\", baseURIDescriptor);\r\n  }\r\n  scope.importer = importer;\r\n  scope.importLoader = importLoader;\r\n});\r\n\r\nwindow.HTMLImports.addModule(function(scope) {\r\n  var parser = scope.parser;\r\n  var importer = scope.importer;\r\n  var dynamic = {\r\n    added: function(nodes) {\r\n      var owner, parsed, loading;\r\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\r\n        if (!owner) {\r\n          owner = n.ownerDocument;\r\n          parsed = parser.isParsed(owner);\r\n        }\r\n        loading = this.shouldLoadNode(n);\r\n        if (loading) {\r\n          importer.loadNode(n);\r\n        }\r\n        if (this.shouldParseNode(n) && parsed) {\r\n          parser.parseDynamic(n, loading);\r\n        }\r\n      }\r\n    },\r\n    shouldLoadNode: function(node) {\r\n      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));\r\n    },\r\n    shouldParseNode: function(node) {\r\n      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));\r\n    }\r\n  };\r\n  importer.observer.addCallback = dynamic.added.bind(dynamic);\r\n  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;\r\n});\r\n\r\n(function(scope) {\r\n  var initializeModules = scope.initializeModules;\r\n  var isIE = scope.isIE;\r\n  if (scope.useNative) {\r\n    return;\r\n  }\r\n  initializeModules();\r\n  var rootDocument = scope.rootDocument;\r\n  function bootstrap() {\r\n    window.HTMLImports.importer.bootDocument(rootDocument);\r\n  }\r\n  if (document.readyState === \"complete\" || document.readyState === \"interactive\" && !window.attachEvent) {\r\n    bootstrap();\r\n  } else {\r\n    document.addEventListener(\"DOMContentLoaded\", bootstrap);\r\n  }\r\n})(window.HTMLImports);\r\n\r\nwindow.CustomElements = window.CustomElements || {\r\n  flags: {}\r\n};\r\n\r\n(function(scope) {\r\n  var flags = scope.flags;\r\n  var modules = [];\r\n  var addModule = function(module) {\r\n    modules.push(module);\r\n  };\r\n  var initializeModules = function() {\r\n    modules.forEach(function(module) {\r\n      module(scope);\r\n    });\r\n  };\r\n  scope.addModule = addModule;\r\n  scope.initializeModules = initializeModules;\r\n  scope.hasNative = Boolean(document.registerElement);\r\n  scope.isIE = /Trident/.test(navigator.userAgent);\r\n  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\r\n})(window.CustomElements);\r\n\r\nwindow.CustomElements.addModule(function(scope) {\r\n  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : \"none\";\r\n  function forSubtree(node, cb) {\r\n    findAllElements(node, function(e) {\r\n      if (cb(e)) {\r\n        return true;\r\n      }\r\n      forRoots(e, cb);\r\n    });\r\n    forRoots(node, cb);\r\n  }\r\n  function findAllElements(node, find, data) {\r\n    var e = node.firstElementChild;\r\n    if (!e) {\r\n      e = node.firstChild;\r\n      while (e && e.nodeType !== Node.ELEMENT_NODE) {\r\n        e = e.nextSibling;\r\n      }\r\n    }\r\n    while (e) {\r\n      if (find(e, data) !== true) {\r\n        findAllElements(e, find, data);\r\n      }\r\n      e = e.nextElementSibling;\r\n    }\r\n    return null;\r\n  }\r\n  function forRoots(node, cb) {\r\n    var root = node.shadowRoot;\r\n    while (root) {\r\n      forSubtree(root, cb);\r\n      root = root.olderShadowRoot;\r\n    }\r\n  }\r\n  function forDocumentTree(doc, cb) {\r\n    _forDocumentTree(doc, cb, []);\r\n  }\r\n  function _forDocumentTree(doc, cb, processingDocuments) {\r\n    doc = window.wrap(doc);\r\n    if (processingDocuments.indexOf(doc) >= 0) {\r\n      return;\r\n    }\r\n    processingDocuments.push(doc);\r\n    var imports = doc.querySelectorAll(\"link[rel=\" + IMPORT_LINK_TYPE + \"]\");\r\n    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {\r\n      if (n.import) {\r\n        _forDocumentTree(n.import, cb, processingDocuments);\r\n      }\r\n    }\r\n    cb(doc);\r\n  }\r\n  scope.forDocumentTree = forDocumentTree;\r\n  scope.forSubtree = forSubtree;\r\n});\r\n\r\nwindow.CustomElements.addModule(function(scope) {\r\n  var flags = scope.flags;\r\n  var forSubtree = scope.forSubtree;\r\n  var forDocumentTree = scope.forDocumentTree;\r\n  function addedNode(node, isAttached) {\r\n    return added(node, isAttached) || addedSubtree(node, isAttached);\r\n  }\r\n  function added(node, isAttached) {\r\n    if (scope.upgrade(node, isAttached)) {\r\n      return true;\r\n    }\r\n    if (isAttached) {\r\n      attached(node);\r\n    }\r\n  }\r\n  function addedSubtree(node, isAttached) {\r\n    forSubtree(node, function(e) {\r\n      if (added(e, isAttached)) {\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags[\"throttle-attached\"];\r\n  scope.hasPolyfillMutations = hasThrottledAttached;\r\n  scope.hasThrottledAttached = hasThrottledAttached;\r\n  var isPendingMutations = false;\r\n  var pendingMutations = [];\r\n  function deferMutation(fn) {\r\n    pendingMutations.push(fn);\r\n    if (!isPendingMutations) {\r\n      isPendingMutations = true;\r\n      setTimeout(takeMutations);\r\n    }\r\n  }\r\n  function takeMutations() {\r\n    isPendingMutations = false;\r\n    var $p = pendingMutations;\r\n    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\r\n      p();\r\n    }\r\n    pendingMutations = [];\r\n  }\r\n  function attached(element) {\r\n    if (hasThrottledAttached) {\r\n      deferMutation(function() {\r\n        _attached(element);\r\n      });\r\n    } else {\r\n      _attached(element);\r\n    }\r\n  }\r\n  function _attached(element) {\r\n    if (element.__upgraded__ && !element.__attached) {\r\n      element.__attached = true;\r\n      if (element.attachedCallback) {\r\n        element.attachedCallback();\r\n      }\r\n    }\r\n  }\r\n  function detachedNode(node) {\r\n    detached(node);\r\n    forSubtree(node, function(e) {\r\n      detached(e);\r\n    });\r\n  }\r\n  function detached(element) {\r\n    if (hasThrottledAttached) {\r\n      deferMutation(function() {\r\n        _detached(element);\r\n      });\r\n    } else {\r\n      _detached(element);\r\n    }\r\n  }\r\n  function _detached(element) {\r\n    if (element.__upgraded__ && element.__attached) {\r\n      element.__attached = false;\r\n      if (element.detachedCallback) {\r\n        element.detachedCallback();\r\n      }\r\n    }\r\n  }\r\n  function inDocument(element) {\r\n    var p = element;\r\n    var doc = window.wrap(document);\r\n    while (p) {\r\n      if (p == doc) {\r\n        return true;\r\n      }\r\n      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;\r\n    }\r\n  }\r\n  function watchShadow(node) {\r\n    if (node.shadowRoot && !node.shadowRoot.__watched) {\r\n      flags.dom && console.log(\"watching shadow-root for: \", node.localName);\r\n      var root = node.shadowRoot;\r\n      while (root) {\r\n        observe(root);\r\n        root = root.olderShadowRoot;\r\n      }\r\n    }\r\n  }\r\n  function handler(root, mutations) {\r\n    if (flags.dom) {\r\n      var mx = mutations[0];\r\n      if (mx && mx.type === \"childList\" && mx.addedNodes) {\r\n        if (mx.addedNodes) {\r\n          var d = mx.addedNodes[0];\r\n          while (d && d !== document && !d.host) {\r\n            d = d.parentNode;\r\n          }\r\n          var u = d && (d.URL || d._URL || d.host && d.host.localName) || \"\";\r\n          u = u.split(\"/?\").shift().split(\"/\").pop();\r\n        }\r\n      }\r\n      console.group(\"mutations (%d) [%s]\", mutations.length, u || \"\");\r\n    }\r\n    var isAttached = inDocument(root);\r\n    mutations.forEach(function(mx) {\r\n      if (mx.type === \"childList\") {\r\n        forEach(mx.addedNodes, function(n) {\r\n          if (!n.localName) {\r\n            return;\r\n          }\r\n          addedNode(n, isAttached);\r\n        });\r\n        forEach(mx.removedNodes, function(n) {\r\n          if (!n.localName) {\r\n            return;\r\n          }\r\n          detachedNode(n);\r\n        });\r\n      }\r\n    });\r\n    flags.dom && console.groupEnd();\r\n  }\r\n  function takeRecords(node) {\r\n    node = window.wrap(node);\r\n    if (!node) {\r\n      node = window.wrap(document);\r\n    }\r\n    while (node.parentNode) {\r\n      node = node.parentNode;\r\n    }\r\n    var observer = node.__observer;\r\n    if (observer) {\r\n      handler(node, observer.takeRecords());\r\n      takeMutations();\r\n    }\r\n  }\r\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\r\n  function observe(inRoot) {\r\n    if (inRoot.__observer) {\r\n      return;\r\n    }\r\n    var observer = new MutationObserver(handler.bind(this, inRoot));\r\n    observer.observe(inRoot, {\r\n      childList: true,\r\n      subtree: true\r\n    });\r\n    inRoot.__observer = observer;\r\n  }\r\n  function upgradeDocument(doc) {\r\n    doc = window.wrap(doc);\r\n    flags.dom && console.group(\"upgradeDocument: \", doc.baseURI.split(\"/\").pop());\r\n    var isMainDocument = doc === window.wrap(document);\r\n    addedNode(doc, isMainDocument);\r\n    observe(doc);\r\n    flags.dom && console.groupEnd();\r\n  }\r\n  function upgradeDocumentTree(doc) {\r\n    forDocumentTree(doc, upgradeDocument);\r\n  }\r\n  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\r\n  if (originalCreateShadowRoot) {\r\n    Element.prototype.createShadowRoot = function() {\r\n      var root = originalCreateShadowRoot.call(this);\r\n      window.CustomElements.watchShadow(this);\r\n      return root;\r\n    };\r\n  }\r\n  scope.watchShadow = watchShadow;\r\n  scope.upgradeDocumentTree = upgradeDocumentTree;\r\n  scope.upgradeDocument = upgradeDocument;\r\n  scope.upgradeSubtree = addedSubtree;\r\n  scope.upgradeAll = addedNode;\r\n  scope.attached = attached;\r\n  scope.takeRecords = takeRecords;\r\n});\r\n\r\nwindow.CustomElements.addModule(function(scope) {\r\n  var flags = scope.flags;\r\n  function upgrade(node, isAttached) {\r\n    if (node.localName === \"template\") {\r\n      if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\r\n        HTMLTemplateElement.decorate(node);\r\n      }\r\n    }\r\n    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\r\n      var is = node.getAttribute(\"is\");\r\n      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);\r\n      if (definition) {\r\n        if (is && definition.tag == node.localName || !is && !definition.extends) {\r\n          return upgradeWithDefinition(node, definition, isAttached);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function upgradeWithDefinition(element, definition, isAttached) {\r\n    flags.upgrade && console.group(\"upgrade:\", element.localName);\r\n    if (definition.is) {\r\n      element.setAttribute(\"is\", definition.is);\r\n    }\r\n    implementPrototype(element, definition);\r\n    element.__upgraded__ = true;\r\n    created(element);\r\n    if (isAttached) {\r\n      scope.attached(element);\r\n    }\r\n    scope.upgradeSubtree(element, isAttached);\r\n    flags.upgrade && console.groupEnd();\r\n    return element;\r\n  }\r\n  function implementPrototype(element, definition) {\r\n    if (Object.__proto__) {\r\n      element.__proto__ = definition.prototype;\r\n    } else {\r\n      customMixin(element, definition.prototype, definition.native);\r\n      element.__proto__ = definition.prototype;\r\n    }\r\n  }\r\n  function customMixin(inTarget, inSrc, inNative) {\r\n    var used = {};\r\n    var p = inSrc;\r\n    while (p !== inNative && p !== HTMLElement.prototype) {\r\n      var keys = Object.getOwnPropertyNames(p);\r\n      for (var i = 0, k; k = keys[i]; i++) {\r\n        if (!used[k]) {\r\n          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));\r\n          used[k] = 1;\r\n        }\r\n      }\r\n      p = Object.getPrototypeOf(p);\r\n    }\r\n  }\r\n  function created(element) {\r\n    if (element.createdCallback) {\r\n      element.createdCallback();\r\n    }\r\n  }\r\n  scope.upgrade = upgrade;\r\n  scope.upgradeWithDefinition = upgradeWithDefinition;\r\n  scope.implementPrototype = implementPrototype;\r\n});\r\n\r\nwindow.CustomElements.addModule(function(scope) {\r\n  var isIE = scope.isIE;\r\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\r\n  var upgradeAll = scope.upgradeAll;\r\n  var upgradeWithDefinition = scope.upgradeWithDefinition;\r\n  var implementPrototype = scope.implementPrototype;\r\n  var useNative = scope.useNative;\r\n  function register(name, options) {\r\n    var definition = options || {};\r\n    if (!name) {\r\n      throw new Error(\"document.registerElement: first argument `name` must not be empty\");\r\n    }\r\n    if (name.indexOf(\"-\") < 0) {\r\n      throw new Error(\"document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '\" + String(name) + \"'.\");\r\n    }\r\n    if (isReservedTag(name)) {\r\n      throw new Error(\"Failed to execute 'registerElement' on 'Document': Registration failed for type '\" + String(name) + \"'. The type name is invalid.\");\r\n    }\r\n    if (getRegisteredDefinition(name)) {\r\n      throw new Error(\"DuplicateDefinitionError: a type with name '\" + String(name) + \"' is already registered\");\r\n    }\r\n    if (!definition.prototype) {\r\n      definition.prototype = Object.create(HTMLElement.prototype);\r\n    }\r\n    definition.__name = name.toLowerCase();\r\n    definition.lifecycle = definition.lifecycle || {};\r\n    definition.ancestry = ancestry(definition.extends);\r\n    resolveTagName(definition);\r\n    resolvePrototypeChain(definition);\r\n    overrideAttributeApi(definition.prototype);\r\n    registerDefinition(definition.__name, definition);\r\n    definition.ctor = generateConstructor(definition);\r\n    definition.ctor.prototype = definition.prototype;\r\n    definition.prototype.constructor = definition.ctor;\r\n    if (scope.ready) {\r\n      upgradeDocumentTree(document);\r\n    }\r\n    return definition.ctor;\r\n  }\r\n  function overrideAttributeApi(prototype) {\r\n    if (prototype.setAttribute._polyfilled) {\r\n      return;\r\n    }\r\n    var setAttribute = prototype.setAttribute;\r\n    prototype.setAttribute = function(name, value) {\r\n      changeAttribute.call(this, name, value, setAttribute);\r\n    };\r\n    var removeAttribute = prototype.removeAttribute;\r\n    prototype.removeAttribute = function(name) {\r\n      changeAttribute.call(this, name, null, removeAttribute);\r\n    };\r\n    prototype.setAttribute._polyfilled = true;\r\n  }\r\n  function changeAttribute(name, value, operation) {\r\n    name = name.toLowerCase();\r\n    var oldValue = this.getAttribute(name);\r\n    operation.apply(this, arguments);\r\n    var newValue = this.getAttribute(name);\r\n    if (this.attributeChangedCallback && newValue !== oldValue) {\r\n      this.attributeChangedCallback(name, oldValue, newValue);\r\n    }\r\n  }\r\n  function isReservedTag(name) {\r\n    for (var i = 0; i < reservedTagList.length; i++) {\r\n      if (name === reservedTagList[i]) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  var reservedTagList = [ \"annotation-xml\", \"color-profile\", \"font-face\", \"font-face-src\", \"font-face-uri\", \"font-face-format\", \"font-face-name\", \"missing-glyph\" ];\r\n  function ancestry(extnds) {\r\n    var extendee = getRegisteredDefinition(extnds);\r\n    if (extendee) {\r\n      return ancestry(extendee.extends).concat([ extendee ]);\r\n    }\r\n    return [];\r\n  }\r\n  function resolveTagName(definition) {\r\n    var baseTag = definition.extends;\r\n    for (var i = 0, a; a = definition.ancestry[i]; i++) {\r\n      baseTag = a.is && a.tag;\r\n    }\r\n    definition.tag = baseTag || definition.__name;\r\n    if (baseTag) {\r\n      definition.is = definition.__name;\r\n    }\r\n  }\r\n  function resolvePrototypeChain(definition) {\r\n    if (!Object.__proto__) {\r\n      var nativePrototype = HTMLElement.prototype;\r\n      if (definition.is) {\r\n        var inst = document.createElement(definition.tag);\r\n        nativePrototype = Object.getPrototypeOf(inst);\r\n      }\r\n      var proto = definition.prototype, ancestor;\r\n      var foundPrototype = false;\r\n      while (proto) {\r\n        if (proto == nativePrototype) {\r\n          foundPrototype = true;\r\n        }\r\n        ancestor = Object.getPrototypeOf(proto);\r\n        if (ancestor) {\r\n          proto.__proto__ = ancestor;\r\n        }\r\n        proto = ancestor;\r\n      }\r\n      if (!foundPrototype) {\r\n        console.warn(definition.tag + \" prototype not found in prototype chain for \" + definition.is);\r\n      }\r\n      definition.native = nativePrototype;\r\n    }\r\n  }\r\n  function instantiate(definition) {\r\n    return upgradeWithDefinition(domCreateElement(definition.tag), definition);\r\n  }\r\n  var registry = {};\r\n  function getRegisteredDefinition(name) {\r\n    if (name) {\r\n      return registry[name.toLowerCase()];\r\n    }\r\n  }\r\n  function registerDefinition(name, definition) {\r\n    registry[name] = definition;\r\n  }\r\n  function generateConstructor(definition) {\r\n    return function() {\r\n      return instantiate(definition);\r\n    };\r\n  }\r\n  var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\r\n  function createElementNS(namespace, tag, typeExtension) {\r\n    if (namespace === HTML_NAMESPACE) {\r\n      return createElement(tag, typeExtension);\r\n    } else {\r\n      return domCreateElementNS(namespace, tag);\r\n    }\r\n  }\r\n  function createElement(tag, typeExtension) {\r\n    if (tag) {\r\n      tag = tag.toLowerCase();\r\n    }\r\n    if (typeExtension) {\r\n      typeExtension = typeExtension.toLowerCase();\r\n    }\r\n    var definition = getRegisteredDefinition(typeExtension || tag);\r\n    if (definition) {\r\n      if (tag == definition.tag && typeExtension == definition.is) {\r\n        return new definition.ctor();\r\n      }\r\n      if (!typeExtension && !definition.is) {\r\n        return new definition.ctor();\r\n      }\r\n    }\r\n    var element;\r\n    if (typeExtension) {\r\n      element = createElement(tag);\r\n      element.setAttribute(\"is\", typeExtension);\r\n      return element;\r\n    }\r\n    element = domCreateElement(tag);\r\n    if (tag.indexOf(\"-\") >= 0) {\r\n      implementPrototype(element, HTMLElement);\r\n    }\r\n    return element;\r\n  }\r\n  var domCreateElement = document.createElement.bind(document);\r\n  var domCreateElementNS = document.createElementNS.bind(document);\r\n  var isInstance;\r\n  if (!Object.__proto__ && !useNative) {\r\n    isInstance = function(obj, ctor) {\r\n      if (obj instanceof ctor) {\r\n        return true;\r\n      }\r\n      var p = obj;\r\n      while (p) {\r\n        if (p === ctor.prototype) {\r\n          return true;\r\n        }\r\n        p = p.__proto__;\r\n      }\r\n      return false;\r\n    };\r\n  } else {\r\n    isInstance = function(obj, base) {\r\n      return obj instanceof base;\r\n    };\r\n  }\r\n  function wrapDomMethodToForceUpgrade(obj, methodName) {\r\n    var orig = obj[methodName];\r\n    obj[methodName] = function() {\r\n      var n = orig.apply(this, arguments);\r\n      upgradeAll(n);\r\n      return n;\r\n    };\r\n  }\r\n  wrapDomMethodToForceUpgrade(Node.prototype, \"cloneNode\");\r\n  wrapDomMethodToForceUpgrade(document, \"importNode\");\r\n  if (isIE) {\r\n    (function() {\r\n      var importNode = document.importNode;\r\n      document.importNode = function() {\r\n        var n = importNode.apply(document, arguments);\r\n        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {\r\n          var f = document.createDocumentFragment();\r\n          f.appendChild(n);\r\n          return f;\r\n        } else {\r\n          return n;\r\n        }\r\n      };\r\n    })();\r\n  }\r\n  document.registerElement = register;\r\n  document.createElement = createElement;\r\n  document.createElementNS = createElementNS;\r\n  scope.registry = registry;\r\n  scope.instanceof = isInstance;\r\n  scope.reservedTagList = reservedTagList;\r\n  scope.getRegisteredDefinition = getRegisteredDefinition;\r\n  document.register = document.registerElement;\r\n});\r\n\r\n(function(scope) {\r\n  var useNative = scope.useNative;\r\n  var initializeModules = scope.initializeModules;\r\n  var isIE = scope.isIE;\r\n  if (useNative) {\r\n    var nop = function() {};\r\n    scope.watchShadow = nop;\r\n    scope.upgrade = nop;\r\n    scope.upgradeAll = nop;\r\n    scope.upgradeDocumentTree = nop;\r\n    scope.upgradeSubtree = nop;\r\n    scope.takeRecords = nop;\r\n    scope.instanceof = function(obj, base) {\r\n      return obj instanceof base;\r\n    };\r\n  } else {\r\n    initializeModules();\r\n  }\r\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\r\n  var upgradeDocument = scope.upgradeDocument;\r\n  if (!window.wrap) {\r\n    if (window.ShadowDOMPolyfill) {\r\n      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\r\n      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\r\n    } else {\r\n      window.wrap = window.unwrap = function(node) {\r\n        return node;\r\n      };\r\n    }\r\n  }\r\n  if (window.HTMLImports) {\r\n    window.HTMLImports.__importsParsingHook = function(elt) {\r\n      if (elt.import) {\r\n        upgradeDocument(wrap(elt.import));\r\n      }\r\n    };\r\n  }\r\n  function bootstrap() {\r\n    upgradeDocumentTree(window.wrap(document));\r\n    window.CustomElements.ready = true;\r\n    var requestAnimationFrame = window.requestAnimationFrame || function(f) {\r\n      setTimeout(f, 16);\r\n    };\r\n    requestAnimationFrame(function() {\r\n      setTimeout(function() {\r\n        window.CustomElements.readyTime = Date.now();\r\n        if (window.HTMLImports) {\r\n          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\r\n        }\r\n        document.dispatchEvent(new CustomEvent(\"WebComponentsReady\", {\r\n          bubbles: true\r\n        }));\r\n      });\r\n    });\r\n  }\r\n  if (document.readyState === \"complete\" || scope.flags.eager) {\r\n    bootstrap();\r\n  } else if (document.readyState === \"interactive\" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {\r\n    bootstrap();\r\n  } else {\r\n    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? \"HTMLImportsLoaded\" : \"DOMContentLoaded\";\r\n    window.addEventListener(loadEvent, bootstrap);\r\n  }\r\n})(window.CustomElements);\r\n\r\n(function(scope) {\r\n  var style = document.createElement(\"style\");\r\n  style.textContent = \"\" + \"body {\" + \"transition: opacity ease-in 0.2s;\" + \" } \\n\" + \"body[unresolved] {\" + \"opacity: 0; display: block; overflow: hidden; position: relative;\" + \" } \\n\";\r\n  var head = document.querySelector(\"head\");\r\n  head.insertBefore(style, head.firstChild);\r\n})(window.WebComponents);\r\n/*!\r\n * PEP v0.4.1 | https://github.com/jquery/PEP\r\n * Copyright jQuery Foundation and other contributors | http://jquery.org/license\r\n */\r\n(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  global.PointerEventsPolyfill = factory()\r\n}(this, function () { 'use strict';\r\n\r\n  /**\r\n   * This is the constructor for new PointerEvents.\r\n   *\r\n   * New Pointer Events must be given a type, and an optional dictionary of\r\n   * initialization properties.\r\n   *\r\n   * Due to certain platform requirements, events returned from the constructor\r\n   * identify as MouseEvents.\r\n   *\r\n   * @constructor\r\n   * @param {String} inType The type of the event to create.\r\n   * @param {Object} [inDict] An optional dictionary of initial event properties.\r\n   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.\r\n   */\r\n  var MOUSE_PROPS = [\r\n    'bubbles',\r\n    'cancelable',\r\n    'view',\r\n    'detail',\r\n    'screenX',\r\n    'screenY',\r\n    'clientX',\r\n    'clientY',\r\n    'ctrlKey',\r\n    'altKey',\r\n    'shiftKey',\r\n    'metaKey',\r\n    'button',\r\n    'relatedTarget',\r\n    'pageX',\r\n    'pageY'\r\n  ];\r\n\r\n  var MOUSE_DEFAULTS = [\r\n    false,\r\n    false,\r\n    null,\r\n    null,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    false,\r\n    false,\r\n    false,\r\n    false,\r\n    0,\r\n    null,\r\n    0,\r\n    0\r\n  ];\r\n\r\n  function PointerEvent(inType, inDict) {\r\n    inDict = inDict || Object.create(null);\r\n\r\n    var e = document.createEvent('Event');\r\n    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);\r\n\r\n    // define inherited MouseEvent properties\r\n    // skip bubbles and cancelable since they're set above in initEvent()\r\n    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {\r\n      p = MOUSE_PROPS[i];\r\n      e[p] = inDict[p] || MOUSE_DEFAULTS[i];\r\n    }\r\n    e.buttons = inDict.buttons || 0;\r\n\r\n    // Spec requires that pointers without pressure specified use 0.5 for down\r\n    // state and 0 for up state.\r\n    var pressure = 0;\r\n    if (inDict.pressure) {\r\n      pressure = inDict.pressure;\r\n    } else {\r\n      pressure = e.buttons ? 0.5 : 0;\r\n    }\r\n\r\n    // add x/y properties aliased to clientX/Y\r\n    e.x = e.clientX;\r\n    e.y = e.clientY;\r\n\r\n    // define the properties of the PointerEvent interface\r\n    e.pointerId = inDict.pointerId || 0;\r\n    e.width = inDict.width || 0;\r\n    e.height = inDict.height || 0;\r\n    e.pressure = pressure;\r\n    e.tiltX = inDict.tiltX || 0;\r\n    e.tiltY = inDict.tiltY || 0;\r\n    e.pointerType = inDict.pointerType || '';\r\n    e.hwTimestamp = inDict.hwTimestamp || 0;\r\n    e.isPrimary = inDict.isPrimary || false;\r\n    return e;\r\n  }\r\n\r\n  var _PointerEvent = PointerEvent;\r\n\r\n  /**\r\n   * This module implements a map of pointer states\r\n   */\r\n  var USE_MAP = window.Map && window.Map.prototype.forEach;\r\n  var PointerMap = USE_MAP ? Map : SparseArrayMap;\r\n\r\n  function SparseArrayMap() {\r\n    this.array = [];\r\n    this.size = 0;\r\n  }\r\n\r\n  SparseArrayMap.prototype = {\r\n    set: function(k, v) {\r\n      if (v === undefined) {\r\n        return this.delete(k);\r\n      }\r\n      if (!this.has(k)) {\r\n        this.size++;\r\n      }\r\n      this.array[k] = v;\r\n    },\r\n    has: function(k) {\r\n      return this.array[k] !== undefined;\r\n    },\r\n    delete: function(k) {\r\n      if (this.has(k)) {\r\n        delete this.array[k];\r\n        this.size--;\r\n      }\r\n    },\r\n    get: function(k) {\r\n      return this.array[k];\r\n    },\r\n    clear: function() {\r\n      this.array.length = 0;\r\n      this.size = 0;\r\n    },\r\n\r\n    // return value, key, map\r\n    forEach: function(callback, thisArg) {\r\n      return this.array.forEach(function(v, k) {\r\n        callback.call(thisArg, v, k, this);\r\n      }, this);\r\n    }\r\n  };\r\n\r\n  var _pointermap = PointerMap;\r\n\r\n  var CLONE_PROPS = [\r\n\r\n    // MouseEvent\r\n    'bubbles',\r\n    'cancelable',\r\n    'view',\r\n    'detail',\r\n    'screenX',\r\n    'screenY',\r\n    'clientX',\r\n    'clientY',\r\n    'ctrlKey',\r\n    'altKey',\r\n    'shiftKey',\r\n    'metaKey',\r\n    'button',\r\n    'relatedTarget',\r\n\r\n    // DOM Level 3\r\n    'buttons',\r\n\r\n    // PointerEvent\r\n    'pointerId',\r\n    'width',\r\n    'height',\r\n    'pressure',\r\n    'tiltX',\r\n    'tiltY',\r\n    'pointerType',\r\n    'hwTimestamp',\r\n    'isPrimary',\r\n\r\n    // event instance\r\n    'type',\r\n    'target',\r\n    'currentTarget',\r\n    'which',\r\n    'pageX',\r\n    'pageY',\r\n    'timeStamp'\r\n  ];\r\n\r\n  var CLONE_DEFAULTS = [\r\n\r\n    // MouseEvent\r\n    false,\r\n    false,\r\n    null,\r\n    null,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    false,\r\n    false,\r\n    false,\r\n    false,\r\n    0,\r\n    null,\r\n\r\n    // DOM Level 3\r\n    0,\r\n\r\n    // PointerEvent\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    0,\r\n    '',\r\n    0,\r\n    false,\r\n\r\n    // event instance\r\n    '',\r\n    null,\r\n    null,\r\n    0,\r\n    0,\r\n    0,\r\n    0\r\n  ];\r\n\r\n  var BOUNDARY_EVENTS = {\r\n    'pointerover': 1,\r\n    'pointerout': 1,\r\n    'pointerenter': 1,\r\n    'pointerleave': 1\r\n  };\r\n\r\n  var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');\r\n\r\n  /**\r\n   * This module is for normalizing events. Mouse and Touch events will be\r\n   * collected here, and fire PointerEvents that have the same semantics, no\r\n   * matter the source.\r\n   * Events fired:\r\n   *   - pointerdown: a pointing is added\r\n   *   - pointerup: a pointer is removed\r\n   *   - pointermove: a pointer is moved\r\n   *   - pointerover: a pointer crosses into an element\r\n   *   - pointerout: a pointer leaves an element\r\n   *   - pointercancel: a pointer will no longer generate events\r\n   */\r\n  var dispatcher = {\r\n    pointermap: new _pointermap(),\r\n    eventMap: Object.create(null),\r\n    captureInfo: Object.create(null),\r\n\r\n    // Scope objects for native events.\r\n    // This exists for ease of testing.\r\n    eventSources: Object.create(null),\r\n    eventSourceList: [],\r\n    /**\r\n     * Add a new event source that will generate pointer events.\r\n     *\r\n     * `inSource` must contain an array of event names named `events`, and\r\n     * functions with the names specified in the `events` array.\r\n     * @param {string} name A name for the event source\r\n     * @param {Object} source A new source of platform events.\r\n     */\r\n    registerSource: function(name, source) {\r\n      var s = source;\r\n      var newEvents = s.events;\r\n      if (newEvents) {\r\n        newEvents.forEach(function(e) {\r\n          if (s[e]) {\r\n            this.eventMap[e] = s[e].bind(s);\r\n          }\r\n        }, this);\r\n        this.eventSources[name] = s;\r\n        this.eventSourceList.push(s);\r\n      }\r\n    },\r\n    register: function(element) {\r\n      var l = this.eventSourceList.length;\r\n      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {\r\n\r\n        // call eventsource register\r\n        es.register.call(es, element);\r\n      }\r\n    },\r\n    unregister: function(element) {\r\n      var l = this.eventSourceList.length;\r\n      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {\r\n\r\n        // call eventsource register\r\n        es.unregister.call(es, element);\r\n      }\r\n    },\r\n    contains: /*scope.external.contains || */function(container, contained) {\r\n      try {\r\n        return container.contains(contained);\r\n      } catch (ex) {\r\n\r\n        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427\r\n        return false;\r\n      }\r\n    },\r\n\r\n    // EVENTS\r\n    down: function(inEvent) {\r\n      inEvent.bubbles = true;\r\n      this.fireEvent('pointerdown', inEvent);\r\n    },\r\n    move: function(inEvent) {\r\n      inEvent.bubbles = true;\r\n      this.fireEvent('pointermove', inEvent);\r\n    },\r\n    up: function(inEvent) {\r\n      inEvent.bubbles = true;\r\n      this.fireEvent('pointerup', inEvent);\r\n    },\r\n    enter: function(inEvent) {\r\n      inEvent.bubbles = false;\r\n      this.fireEvent('pointerenter', inEvent);\r\n    },\r\n    leave: function(inEvent) {\r\n      inEvent.bubbles = false;\r\n      this.fireEvent('pointerleave', inEvent);\r\n    },\r\n    over: function(inEvent) {\r\n      inEvent.bubbles = true;\r\n      this.fireEvent('pointerover', inEvent);\r\n    },\r\n    out: function(inEvent) {\r\n      inEvent.bubbles = true;\r\n      this.fireEvent('pointerout', inEvent);\r\n    },\r\n    cancel: function(inEvent) {\r\n      inEvent.bubbles = true;\r\n      this.fireEvent('pointercancel', inEvent);\r\n    },\r\n    leaveOut: function(event) {\r\n      this.out(event);\r\n      if (!this.contains(event.target, event.relatedTarget)) {\r\n        this.leave(event);\r\n      }\r\n    },\r\n    enterOver: function(event) {\r\n      this.over(event);\r\n      if (!this.contains(event.target, event.relatedTarget)) {\r\n        this.enter(event);\r\n      }\r\n    },\r\n\r\n    // LISTENER LOGIC\r\n    eventHandler: function(inEvent) {\r\n\r\n      // This is used to prevent multiple dispatch of pointerevents from\r\n      // platform events. This can happen when two elements in different scopes\r\n      // are set up to create pointer events, which is relevant to Shadow DOM.\r\n      if (inEvent._handledByPE) {\r\n        return;\r\n      }\r\n      var type = inEvent.type;\r\n      var fn = this.eventMap && this.eventMap[type];\r\n      if (fn) {\r\n        fn(inEvent);\r\n      }\r\n      inEvent._handledByPE = true;\r\n    },\r\n\r\n    // set up event listeners\r\n    listen: function(target, events) {\r\n      events.forEach(function(e) {\r\n        this.addEvent(target, e);\r\n      }, this);\r\n    },\r\n\r\n    // remove event listeners\r\n    unlisten: function(target, events) {\r\n      events.forEach(function(e) {\r\n        this.removeEvent(target, e);\r\n      }, this);\r\n    },\r\n    addEvent: /*scope.external.addEvent || */function(target, eventName) {\r\n      target.addEventListener(eventName, this.boundHandler);\r\n    },\r\n    removeEvent: /*scope.external.removeEvent || */function(target, eventName) {\r\n      target.removeEventListener(eventName, this.boundHandler);\r\n    },\r\n\r\n    // EVENT CREATION AND TRACKING\r\n    /**\r\n     * Creates a new Event of type `inType`, based on the information in\r\n     * `inEvent`.\r\n     *\r\n     * @param {string} inType A string representing the type of event to create\r\n     * @param {Event} inEvent A platform event with a target\r\n     * @return {Event} A PointerEvent of type `inType`\r\n     */\r\n    makeEvent: function(inType, inEvent) {\r\n\r\n      // relatedTarget must be null if pointer is captured\r\n      if (this.captureInfo[inEvent.pointerId]) {\r\n        inEvent.relatedTarget = null;\r\n      }\r\n      var e = new _PointerEvent(inType, inEvent);\r\n      if (inEvent.preventDefault) {\r\n        e.preventDefault = inEvent.preventDefault;\r\n      }\r\n      e._target = e._target || inEvent.target;\r\n      return e;\r\n    },\r\n\r\n    // make and dispatch an event in one call\r\n    fireEvent: function(inType, inEvent) {\r\n      var e = this.makeEvent(inType, inEvent);\r\n      return this.dispatchEvent(e);\r\n    },\r\n    /**\r\n     * Returns a snapshot of inEvent, with writable properties.\r\n     *\r\n     * @param {Event} inEvent An event that contains properties to copy.\r\n     * @return {Object} An object containing shallow copies of `inEvent`'s\r\n     *    properties.\r\n     */\r\n    cloneEvent: function(inEvent) {\r\n      var eventCopy = Object.create(null);\r\n      var p;\r\n      for (var i = 0; i < CLONE_PROPS.length; i++) {\r\n        p = CLONE_PROPS[i];\r\n        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];\r\n\r\n        // Work around SVGInstanceElement shadow tree\r\n        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.\r\n        // This is the behavior implemented by Firefox.\r\n        if (HAS_SVG_INSTANCE && (p === 'target' || p === 'relatedTarget')) {\r\n          if (eventCopy[p] instanceof SVGElementInstance) {\r\n            eventCopy[p] = eventCopy[p].correspondingUseElement;\r\n          }\r\n        }\r\n      }\r\n\r\n      // keep the semantics of preventDefault\r\n      if (inEvent.preventDefault) {\r\n        eventCopy.preventDefault = function() {\r\n          inEvent.preventDefault();\r\n        };\r\n      }\r\n      return eventCopy;\r\n    },\r\n    getTarget: function(inEvent) {\r\n      var capture = this.captureInfo[inEvent.pointerId];\r\n      if (!capture) {\r\n        return inEvent._target;\r\n      }\r\n      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {\r\n        return capture;\r\n      }\r\n    },\r\n    setCapture: function(inPointerId, inTarget) {\r\n      if (this.captureInfo[inPointerId]) {\r\n        this.releaseCapture(inPointerId);\r\n      }\r\n      this.captureInfo[inPointerId] = inTarget;\r\n      var e = document.createEvent('Event');\r\n      e.initEvent('gotpointercapture', true, false);\r\n      e.pointerId = inPointerId;\r\n      this.implicitRelease = this.releaseCapture.bind(this, inPointerId);\r\n      document.addEventListener('pointerup', this.implicitRelease);\r\n      document.addEventListener('pointercancel', this.implicitRelease);\r\n      e._target = inTarget;\r\n      this.asyncDispatchEvent(e);\r\n    },\r\n    releaseCapture: function(inPointerId) {\r\n      var t = this.captureInfo[inPointerId];\r\n      if (t) {\r\n        var e = document.createEvent('Event');\r\n        e.initEvent('lostpointercapture', true, false);\r\n        e.pointerId = inPointerId;\r\n        this.captureInfo[inPointerId] = undefined;\r\n        document.removeEventListener('pointerup', this.implicitRelease);\r\n        document.removeEventListener('pointercancel', this.implicitRelease);\r\n        e._target = t;\r\n        this.asyncDispatchEvent(e);\r\n      }\r\n    },\r\n    /**\r\n     * Dispatches the event to its target.\r\n     *\r\n     * @param {Event} inEvent The event to be dispatched.\r\n     * @return {Boolean} True if an event handler returns true, false otherwise.\r\n     */\r\n    dispatchEvent: /*scope.external.dispatchEvent || */function(inEvent) {\r\n      var t = this.getTarget(inEvent);\r\n      if (t) {\r\n        return t.dispatchEvent(inEvent);\r\n      }\r\n    },\r\n    asyncDispatchEvent: function(inEvent) {\r\n      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));\r\n    }\r\n  };\r\n  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);\r\n\r\n  var _dispatcher = dispatcher;\r\n\r\n  var targeting = {\r\n    shadow: function(inEl) {\r\n      if (inEl) {\r\n        return inEl.shadowRoot || inEl.webkitShadowRoot;\r\n      }\r\n    },\r\n    canTarget: function(shadow) {\r\n      return shadow && Boolean(shadow.elementFromPoint);\r\n    },\r\n    targetingShadow: function(inEl) {\r\n      var s = this.shadow(inEl);\r\n      if (this.canTarget(s)) {\r\n        return s;\r\n      }\r\n    },\r\n    olderShadow: function(shadow) {\r\n      var os = shadow.olderShadowRoot;\r\n      if (!os) {\r\n        var se = shadow.querySelector('shadow');\r\n        if (se) {\r\n          os = se.olderShadowRoot;\r\n        }\r\n      }\r\n      return os;\r\n    },\r\n    allShadows: function(element) {\r\n      var shadows = [];\r\n      var s = this.shadow(element);\r\n      while (s) {\r\n        shadows.push(s);\r\n        s = this.olderShadow(s);\r\n      }\r\n      return shadows;\r\n    },\r\n    searchRoot: function(inRoot, x, y) {\r\n      if (inRoot) {\r\n        var t = inRoot.elementFromPoint(x, y);\r\n        var st, sr;\r\n\r\n        // is element a shadow host?\r\n        sr = this.targetingShadow(t);\r\n        while (sr) {\r\n\r\n          // find the the element inside the shadow root\r\n          st = sr.elementFromPoint(x, y);\r\n          if (!st) {\r\n\r\n            // check for older shadows\r\n            sr = this.olderShadow(sr);\r\n          } else {\r\n\r\n            // shadowed element may contain a shadow root\r\n            var ssr = this.targetingShadow(st);\r\n            return this.searchRoot(ssr, x, y) || st;\r\n          }\r\n        }\r\n\r\n        // light dom element is the target\r\n        return t;\r\n      }\r\n    },\r\n    owner: function(element) {\r\n      var s = element;\r\n\r\n      // walk up until you hit the shadow root or document\r\n      while (s.parentNode) {\r\n        s = s.parentNode;\r\n      }\r\n\r\n      // the owner element is expected to be a Document or ShadowRoot\r\n      if (s.nodeType !== Node.DOCUMENT_NODE && s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\r\n        s = document;\r\n      }\r\n      return s;\r\n    },\r\n    findTarget: function(inEvent) {\r\n      var x = inEvent.clientX;\r\n      var y = inEvent.clientY;\r\n\r\n      // if the listener is in the shadow root, it is much faster to start there\r\n      var s = this.owner(inEvent.target);\r\n\r\n      // if x, y is not in this root, fall back to document search\r\n      if (!s.elementFromPoint(x, y)) {\r\n        s = document;\r\n      }\r\n      return this.searchRoot(s, x, y);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * This module uses Mutation Observers to dynamically adjust which nodes will\r\n   * generate Pointer Events.\r\n   *\r\n   * All nodes that wish to generate Pointer Events must have the attribute\r\n   * `touch-action` set to `none`.\r\n   */\r\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\r\n  var map = Array.prototype.map.call.bind(Array.prototype.map);\r\n  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);\r\n  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);\r\n  var MO = window.MutationObserver || window.WebKitMutationObserver;\r\n  var SELECTOR = '[touch-action]';\r\n  var OBSERVER_INIT = {\r\n    subtree: true,\r\n    childList: true,\r\n    attributes: true,\r\n    attributeOldValue: true,\r\n    attributeFilter: ['touch-action']\r\n  };\r\n\r\n  function Installer(add, remove, changed, binder) {\r\n    this.addCallback = add.bind(binder);\r\n    this.removeCallback = remove.bind(binder);\r\n    this.changedCallback = changed.bind(binder);\r\n    if (MO) {\r\n      this.observer = new MO(this.mutationWatcher.bind(this));\r\n    }\r\n  }\r\n\r\n  Installer.prototype = {\r\n    watchSubtree: function(target) {\r\n\r\n      // Only watch scopes that can target find, as these are top-level.\r\n      // Otherwise we can see duplicate additions and removals that add noise.\r\n      //\r\n      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see\r\n      // a removal without an insertion when a node is redistributed among\r\n      // shadows. Since it all ends up correct in the document, watching only\r\n      // the document will yield the correct mutations to watch.\r\n      if (this.observer && targeting.canTarget(target)) {\r\n        this.observer.observe(target, OBSERVER_INIT);\r\n      }\r\n    },\r\n    enableOnSubtree: function(target) {\r\n      this.watchSubtree(target);\r\n      if (target === document && document.readyState !== 'complete') {\r\n        this.installOnLoad();\r\n      } else {\r\n        this.installNewSubtree(target);\r\n      }\r\n    },\r\n    installNewSubtree: function(target) {\r\n      forEach(this.findElements(target), this.addElement, this);\r\n    },\r\n    findElements: function(target) {\r\n      if (target.querySelectorAll) {\r\n        return target.querySelectorAll(SELECTOR);\r\n      }\r\n      return [];\r\n    },\r\n    removeElement: function(el) {\r\n      this.removeCallback(el);\r\n    },\r\n    addElement: function(el) {\r\n      this.addCallback(el);\r\n    },\r\n    elementChanged: function(el, oldValue) {\r\n      this.changedCallback(el, oldValue);\r\n    },\r\n    concatLists: function(accum, list) {\r\n      return accum.concat(toArray(list));\r\n    },\r\n\r\n    // register all touch-action = none nodes on document load\r\n    installOnLoad: function() {\r\n      document.addEventListener('readystatechange', function() {\r\n        if (document.readyState === 'complete') {\r\n          this.installNewSubtree(document);\r\n        }\r\n      }.bind(this));\r\n    },\r\n    isElement: function(n) {\r\n      return n.nodeType === Node.ELEMENT_NODE;\r\n    },\r\n    flattenMutationTree: function(inNodes) {\r\n\r\n      // find children with touch-action\r\n      var tree = map(inNodes, this.findElements, this);\r\n\r\n      // make sure the added nodes are accounted for\r\n      tree.push(filter(inNodes, this.isElement));\r\n\r\n      // flatten the list\r\n      return tree.reduce(this.concatLists, []);\r\n    },\r\n    mutationWatcher: function(mutations) {\r\n      mutations.forEach(this.mutationHandler, this);\r\n    },\r\n    mutationHandler: function(m) {\r\n      if (m.type === 'childList') {\r\n        var added = this.flattenMutationTree(m.addedNodes);\r\n        added.forEach(this.addElement, this);\r\n        var removed = this.flattenMutationTree(m.removedNodes);\r\n        removed.forEach(this.removeElement, this);\r\n      } else if (m.type === 'attributes') {\r\n        this.elementChanged(m.target, m.oldValue);\r\n      }\r\n    }\r\n  };\r\n\r\n  var installer = Installer;\r\n\r\n  function shadowSelector(v) {\r\n    return 'body /shadow-deep/ ' + selector(v);\r\n  }\r\n  function selector(v) {\r\n    return '[touch-action=\"' + v + '\"]';\r\n  }\r\n  function rule(v) {\r\n    return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + '; touch-action-delay: none; }';\r\n  }\r\n  var attrib2css = [\r\n    'none',\r\n    'auto',\r\n    'pan-x',\r\n    'pan-y',\r\n    {\r\n      rule: 'pan-x pan-y',\r\n      selectors: [\r\n        'pan-x pan-y',\r\n        'pan-y pan-x'\r\n      ]\r\n    }\r\n  ];\r\n  var styles = '';\r\n\r\n  // only install stylesheet if the browser has touch action support\r\n  var hasNativePE = window.PointerEvent || window.MSPointerEvent;\r\n\r\n  // only add shadow selectors if shadowdom is supported\r\n  var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;\r\n\r\n  function applyAttributeStyles() {\r\n    if (hasNativePE) {\r\n      attrib2css.forEach(function(r) {\r\n        if (String(r) === r) {\r\n          styles += selector(r) + rule(r) + '\\n';\r\n          if (hasShadowRoot) {\r\n            styles += shadowSelector(r) + rule(r) + '\\n';\r\n          }\r\n        } else {\r\n          styles += r.selectors.map(selector) + rule(r.rule) + '\\n';\r\n          if (hasShadowRoot) {\r\n            styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\\n';\r\n          }\r\n        }\r\n      });\r\n\r\n      var el = document.createElement('style');\r\n      el.textContent = styles;\r\n      document.head.appendChild(el);\r\n    }\r\n  }\r\n\r\n  var mouse__pointermap = _dispatcher.pointermap;\r\n\r\n  // radius around touchend that swallows mouse events\r\n  var DEDUP_DIST = 25;\r\n\r\n  // left, middle, right, back, forward\r\n  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];\r\n\r\n  var HAS_BUTTONS = false;\r\n  try {\r\n    HAS_BUTTONS = new MouseEvent('test', { buttons: 1 }).buttons === 1;\r\n  } catch (e) {}\r\n\r\n  // handler block for native mouse events\r\n  var mouseEvents = {\r\n    POINTER_ID: 1,\r\n    POINTER_TYPE: 'mouse',\r\n    events: [\r\n      'mousedown',\r\n      'mousemove',\r\n      'mouseup',\r\n      'mouseover',\r\n      'mouseout'\r\n    ],\r\n    register: function(target) {\r\n      _dispatcher.listen(target, this.events);\r\n    },\r\n    unregister: function(target) {\r\n      _dispatcher.unlisten(target, this.events);\r\n    },\r\n    lastTouches: [],\r\n\r\n    // collide with the global mouse listener\r\n    isEventSimulatedFromTouch: function(inEvent) {\r\n      var lts = this.lastTouches;\r\n      var x = inEvent.clientX;\r\n      var y = inEvent.clientY;\r\n      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {\r\n\r\n        // simulated mouse events will be swallowed near a primary touchend\r\n        var dx = Math.abs(x - t.x);\r\n        var dy = Math.abs(y - t.y);\r\n        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {\r\n          return true;\r\n        }\r\n      }\r\n    },\r\n    prepareEvent: function(inEvent) {\r\n      var e = _dispatcher.cloneEvent(inEvent);\r\n\r\n      // forward mouse preventDefault\r\n      var pd = e.preventDefault;\r\n      e.preventDefault = function() {\r\n        inEvent.preventDefault();\r\n        pd();\r\n      };\r\n      e.pointerId = this.POINTER_ID;\r\n      e.isPrimary = true;\r\n      e.pointerType = this.POINTER_TYPE;\r\n      return e;\r\n    },\r\n    prepareButtonsForMove: function(e, inEvent) {\r\n      var p = mouse__pointermap.get(this.POINTER_ID);\r\n      e.buttons = p ? p.buttons : 0;\r\n      inEvent.buttons = e.buttons;\r\n    },\r\n    mousedown: function(inEvent) {\r\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\r\n        var p = mouse__pointermap.get(this.POINTER_ID);\r\n        var e = this.prepareEvent(inEvent);\r\n        if (!HAS_BUTTONS) {\r\n          e.buttons = BUTTON_TO_BUTTONS[e.button];\r\n          if (p) { e.buttons |= p.buttons; }\r\n          inEvent.buttons = e.buttons;\r\n        }\r\n        mouse__pointermap.set(this.POINTER_ID, inEvent);\r\n        if (!p) {\r\n          _dispatcher.down(e);\r\n        } else {\r\n          _dispatcher.move(e);\r\n        }\r\n      }\r\n    },\r\n    mousemove: function(inEvent) {\r\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\r\n        var e = this.prepareEvent(inEvent);\r\n        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }\r\n        _dispatcher.move(e);\r\n      }\r\n    },\r\n    mouseup: function(inEvent) {\r\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\r\n        var p = mouse__pointermap.get(this.POINTER_ID);\r\n        var e = this.prepareEvent(inEvent);\r\n        if (!HAS_BUTTONS) {\r\n          var up = BUTTON_TO_BUTTONS[e.button];\r\n\r\n          // Produces wrong state of buttons in Browsers without `buttons` support\r\n          // when a mouse button that was pressed outside the document is released\r\n          // inside and other buttons are still pressed down.\r\n          e.buttons = p ? p.buttons & ~up : 0;\r\n          inEvent.buttons = e.buttons;\r\n        }\r\n        mouse__pointermap.set(this.POINTER_ID, inEvent);\r\n\r\n        // Support: Firefox <=44 only\r\n        // FF Ubuntu includes the lifted button in the `buttons` property on\r\n        // mouseup.\r\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366\r\n        if (e.buttons === 0 || e.buttons === BUTTON_TO_BUTTONS[e.button]) {\r\n          this.cleanupMouse();\r\n          _dispatcher.up(e);\r\n        } else {\r\n          _dispatcher.move(e);\r\n        }\r\n      }\r\n    },\r\n    mouseover: function(inEvent) {\r\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\r\n        var e = this.prepareEvent(inEvent);\r\n        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }\r\n        _dispatcher.enterOver(e);\r\n      }\r\n    },\r\n    mouseout: function(inEvent) {\r\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\r\n        var e = this.prepareEvent(inEvent);\r\n        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }\r\n        _dispatcher.leaveOut(e);\r\n      }\r\n    },\r\n    cancel: function(inEvent) {\r\n      var e = this.prepareEvent(inEvent);\r\n      _dispatcher.cancel(e);\r\n      this.cleanupMouse();\r\n    },\r\n    cleanupMouse: function() {\r\n      mouse__pointermap.delete(this.POINTER_ID);\r\n    }\r\n  };\r\n\r\n  var mouse = mouseEvents;\r\n\r\n  var captureInfo = _dispatcher.captureInfo;\r\n  var findTarget = targeting.findTarget.bind(targeting);\r\n  var allShadows = targeting.allShadows.bind(targeting);\r\n  var touch__pointermap = _dispatcher.pointermap;\r\n\r\n  // This should be long enough to ignore compat mouse events made by touch\r\n  var DEDUP_TIMEOUT = 2500;\r\n  var CLICK_COUNT_TIMEOUT = 200;\r\n  var ATTRIB = 'touch-action';\r\n  var INSTALLER;\r\n\r\n  // The presence of touch event handlers blocks scrolling, and so we must be careful to\r\n  // avoid adding handlers unnecessarily.  Chrome plans to add a touch-action-delay property\r\n  // (crbug.com/329559) to address this, and once we have that we can opt-in to a simpler\r\n  // handler registration mechanism.  Rather than try to predict how exactly to opt-in to\r\n  // that we'll just leave this disabled until there is a build of Chrome to test.\r\n  var HAS_TOUCH_ACTION_DELAY = false;\r\n\r\n  // handler block for native touch events\r\n  var touchEvents = {\r\n    events: [\r\n      'touchstart',\r\n      'touchmove',\r\n      'touchend',\r\n      'touchcancel'\r\n    ],\r\n    register: function(target) {\r\n      if (HAS_TOUCH_ACTION_DELAY) {\r\n        _dispatcher.listen(target, this.events);\r\n      } else {\r\n        INSTALLER.enableOnSubtree(target);\r\n      }\r\n    },\r\n    unregister: function(target) {\r\n      if (HAS_TOUCH_ACTION_DELAY) {\r\n        _dispatcher.unlisten(target, this.events);\r\n      } else {\r\n\r\n        // TODO(dfreedman): is it worth it to disconnect the MO?\r\n      }\r\n    },\r\n    elementAdded: function(el) {\r\n      var a = el.getAttribute(ATTRIB);\r\n      var st = this.touchActionToScrollType(a);\r\n      if (st) {\r\n        el._scrollType = st;\r\n        _dispatcher.listen(el, this.events);\r\n\r\n        // set touch-action on shadows as well\r\n        allShadows(el).forEach(function(s) {\r\n          s._scrollType = st;\r\n          _dispatcher.listen(s, this.events);\r\n        }, this);\r\n      }\r\n    },\r\n    elementRemoved: function(el) {\r\n      el._scrollType = undefined;\r\n      _dispatcher.unlisten(el, this.events);\r\n\r\n      // remove touch-action from shadow\r\n      allShadows(el).forEach(function(s) {\r\n        s._scrollType = undefined;\r\n        _dispatcher.unlisten(s, this.events);\r\n      }, this);\r\n    },\r\n    elementChanged: function(el, oldValue) {\r\n      var a = el.getAttribute(ATTRIB);\r\n      var st = this.touchActionToScrollType(a);\r\n      var oldSt = this.touchActionToScrollType(oldValue);\r\n\r\n      // simply update scrollType if listeners are already established\r\n      if (st && oldSt) {\r\n        el._scrollType = st;\r\n        allShadows(el).forEach(function(s) {\r\n          s._scrollType = st;\r\n        }, this);\r\n      } else if (oldSt) {\r\n        this.elementRemoved(el);\r\n      } else if (st) {\r\n        this.elementAdded(el);\r\n      }\r\n    },\r\n    scrollTypes: {\r\n      EMITTER: 'none',\r\n      XSCROLLER: 'pan-x',\r\n      YSCROLLER: 'pan-y',\r\n      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/\r\n    },\r\n    touchActionToScrollType: function(touchAction) {\r\n      var t = touchAction;\r\n      var st = this.scrollTypes;\r\n      if (t === 'none') {\r\n        return 'none';\r\n      } else if (t === st.XSCROLLER) {\r\n        return 'X';\r\n      } else if (t === st.YSCROLLER) {\r\n        return 'Y';\r\n      } else if (st.SCROLLER.exec(t)) {\r\n        return 'XY';\r\n      }\r\n    },\r\n    POINTER_TYPE: 'touch',\r\n    firstTouch: null,\r\n    isPrimaryTouch: function(inTouch) {\r\n      return this.firstTouch === inTouch.identifier;\r\n    },\r\n    setPrimaryTouch: function(inTouch) {\r\n\r\n      // set primary touch if there no pointers, or the only pointer is the mouse\r\n      if (touch__pointermap.size === 0 || (touch__pointermap.size === 1 && touch__pointermap.has(1))) {\r\n        this.firstTouch = inTouch.identifier;\r\n        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };\r\n        this.scrolling = false;\r\n        this.cancelResetClickCount();\r\n      }\r\n    },\r\n    removePrimaryPointer: function(inPointer) {\r\n      if (inPointer.isPrimary) {\r\n        this.firstTouch = null;\r\n        this.firstXY = null;\r\n        this.resetClickCount();\r\n      }\r\n    },\r\n    clickCount: 0,\r\n    resetId: null,\r\n    resetClickCount: function() {\r\n      var fn = function() {\r\n        this.clickCount = 0;\r\n        this.resetId = null;\r\n      }.bind(this);\r\n      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);\r\n    },\r\n    cancelResetClickCount: function() {\r\n      if (this.resetId) {\r\n        clearTimeout(this.resetId);\r\n      }\r\n    },\r\n    typeToButtons: function(type) {\r\n      var ret = 0;\r\n      if (type === 'touchstart' || type === 'touchmove') {\r\n        ret = 1;\r\n      }\r\n      return ret;\r\n    },\r\n    touchToPointer: function(inTouch) {\r\n      var cte = this.currentTouchEvent;\r\n      var e = _dispatcher.cloneEvent(inTouch);\r\n\r\n      // We reserve pointerId 1 for Mouse.\r\n      // Touch identifiers can start at 0.\r\n      // Add 2 to the touch identifier for compatibility.\r\n      var id = e.pointerId = inTouch.identifier + 2;\r\n      e.target = captureInfo[id] || findTarget(e);\r\n      e.bubbles = true;\r\n      e.cancelable = true;\r\n      e.detail = this.clickCount;\r\n      e.button = 0;\r\n      e.buttons = this.typeToButtons(cte.type);\r\n      e.width = inTouch.radiusX || inTouch.webkitRadiusX || 0;\r\n      e.height = inTouch.radiusY || inTouch.webkitRadiusY || 0;\r\n      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;\r\n      e.isPrimary = this.isPrimaryTouch(inTouch);\r\n      e.pointerType = this.POINTER_TYPE;\r\n\r\n      // forward touch preventDefaults\r\n      var self = this;\r\n      e.preventDefault = function() {\r\n        self.scrolling = false;\r\n        self.firstXY = null;\r\n        cte.preventDefault();\r\n      };\r\n      return e;\r\n    },\r\n    processTouches: function(inEvent, inFunction) {\r\n      var tl = inEvent.changedTouches;\r\n      this.currentTouchEvent = inEvent;\r\n      for (var i = 0, t; i < tl.length; i++) {\r\n        t = tl[i];\r\n        inFunction.call(this, this.touchToPointer(t));\r\n      }\r\n    },\r\n\r\n    // For single axis scrollers, determines whether the element should emit\r\n    // pointer events or behave as a scroller\r\n    shouldScroll: function(inEvent) {\r\n      if (this.firstXY) {\r\n        var ret;\r\n        var scrollAxis = inEvent.currentTarget._scrollType;\r\n        if (scrollAxis === 'none') {\r\n\r\n          // this element is a touch-action: none, should never scroll\r\n          ret = false;\r\n        } else if (scrollAxis === 'XY') {\r\n\r\n          // this element should always scroll\r\n          ret = true;\r\n        } else {\r\n          var t = inEvent.changedTouches[0];\r\n\r\n          // check the intended scroll axis, and other axis\r\n          var a = scrollAxis;\r\n          var oa = scrollAxis === 'Y' ? 'X' : 'Y';\r\n          var da = Math.abs(t['client' + a] - this.firstXY[a]);\r\n          var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);\r\n\r\n          // if delta in the scroll axis > delta other axis, scroll instead of\r\n          // making events\r\n          ret = da >= doa;\r\n        }\r\n        this.firstXY = null;\r\n        return ret;\r\n      }\r\n    },\r\n    findTouch: function(inTL, inId) {\r\n      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {\r\n        if (t.identifier === inId) {\r\n          return true;\r\n        }\r\n      }\r\n    },\r\n\r\n    // In some instances, a touchstart can happen without a touchend. This\r\n    // leaves the pointermap in a broken state.\r\n    // Therefore, on every touchstart, we remove the touches that did not fire a\r\n    // touchend event.\r\n    // To keep state globally consistent, we fire a\r\n    // pointercancel for this \"abandoned\" touch\r\n    vacuumTouches: function(inEvent) {\r\n      var tl = inEvent.touches;\r\n\r\n      // pointermap.size should be < tl.length here, as the touchstart has not\r\n      // been processed yet.\r\n      if (touch__pointermap.size >= tl.length) {\r\n        var d = [];\r\n        touch__pointermap.forEach(function(value, key) {\r\n\r\n          // Never remove pointerId == 1, which is mouse.\r\n          // Touch identifiers are 2 smaller than their pointerId, which is the\r\n          // index in pointermap.\r\n          if (key !== 1 && !this.findTouch(tl, key - 2)) {\r\n            var p = value.out;\r\n            d.push(p);\r\n          }\r\n        }, this);\r\n        d.forEach(this.cancelOut, this);\r\n      }\r\n    },\r\n    touchstart: function(inEvent) {\r\n      this.vacuumTouches(inEvent);\r\n      this.setPrimaryTouch(inEvent.changedTouches[0]);\r\n      this.dedupSynthMouse(inEvent);\r\n      if (!this.scrolling) {\r\n        this.clickCount++;\r\n        this.processTouches(inEvent, this.overDown);\r\n      }\r\n    },\r\n    overDown: function(inPointer) {\r\n      touch__pointermap.set(inPointer.pointerId, {\r\n        target: inPointer.target,\r\n        out: inPointer,\r\n        outTarget: inPointer.target\r\n      });\r\n      _dispatcher.over(inPointer);\r\n      _dispatcher.enter(inPointer);\r\n      _dispatcher.down(inPointer);\r\n    },\r\n    touchmove: function(inEvent) {\r\n      if (!this.scrolling) {\r\n        if (this.shouldScroll(inEvent)) {\r\n          this.scrolling = true;\r\n          this.touchcancel(inEvent);\r\n        } else {\r\n          inEvent.preventDefault();\r\n          this.processTouches(inEvent, this.moveOverOut);\r\n        }\r\n      }\r\n    },\r\n    moveOverOut: function(inPointer) {\r\n      var event = inPointer;\r\n      var pointer = touch__pointermap.get(event.pointerId);\r\n\r\n      // a finger drifted off the screen, ignore it\r\n      if (!pointer) {\r\n        return;\r\n      }\r\n      var outEvent = pointer.out;\r\n      var outTarget = pointer.outTarget;\r\n      _dispatcher.move(event);\r\n      if (outEvent && outTarget !== event.target) {\r\n        outEvent.relatedTarget = event.target;\r\n        event.relatedTarget = outTarget;\r\n\r\n        // recover from retargeting by shadow\r\n        outEvent.target = outTarget;\r\n        if (event.target) {\r\n          _dispatcher.leaveOut(outEvent);\r\n          _dispatcher.enterOver(event);\r\n        } else {\r\n\r\n          // clean up case when finger leaves the screen\r\n          event.target = outTarget;\r\n          event.relatedTarget = null;\r\n          this.cancelOut(event);\r\n        }\r\n      }\r\n      pointer.out = event;\r\n      pointer.outTarget = event.target;\r\n    },\r\n    touchend: function(inEvent) {\r\n      this.dedupSynthMouse(inEvent);\r\n      this.processTouches(inEvent, this.upOut);\r\n    },\r\n    upOut: function(inPointer) {\r\n      if (!this.scrolling) {\r\n        _dispatcher.up(inPointer);\r\n        _dispatcher.out(inPointer);\r\n        _dispatcher.leave(inPointer);\r\n      }\r\n      this.cleanUpPointer(inPointer);\r\n    },\r\n    touchcancel: function(inEvent) {\r\n      this.processTouches(inEvent, this.cancelOut);\r\n    },\r\n    cancelOut: function(inPointer) {\r\n      _dispatcher.cancel(inPointer);\r\n      _dispatcher.out(inPointer);\r\n      _dispatcher.leave(inPointer);\r\n      this.cleanUpPointer(inPointer);\r\n    },\r\n    cleanUpPointer: function(inPointer) {\r\n      touch__pointermap.delete(inPointer.pointerId);\r\n      this.removePrimaryPointer(inPointer);\r\n    },\r\n\r\n    // prevent synth mouse events from creating pointer events\r\n    dedupSynthMouse: function(inEvent) {\r\n      var lts = mouse.lastTouches;\r\n      var t = inEvent.changedTouches[0];\r\n\r\n      // only the primary finger will synth mouse events\r\n      if (this.isPrimaryTouch(t)) {\r\n\r\n        // remember x/y of last touch\r\n        var lt = { x: t.clientX, y: t.clientY };\r\n        lts.push(lt);\r\n        var fn = (function(lts, lt) {\r\n          var i = lts.indexOf(lt);\r\n          if (i > -1) {\r\n            lts.splice(i, 1);\r\n          }\r\n        }).bind(null, lts, lt);\r\n        setTimeout(fn, DEDUP_TIMEOUT);\r\n      }\r\n    }\r\n  };\r\n\r\n  if (!HAS_TOUCH_ACTION_DELAY) {\r\n    INSTALLER = new installer(touchEvents.elementAdded, touchEvents.elementRemoved,\r\n      touchEvents.elementChanged, touchEvents);\r\n  }\r\n\r\n  var touch = touchEvents;\r\n\r\n  var ms__pointermap = _dispatcher.pointermap;\r\n  var HAS_BITMAP_TYPE = window.MSPointerEvent &&\r\n    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';\r\n  var msEvents = {\r\n    events: [\r\n      'MSPointerDown',\r\n      'MSPointerMove',\r\n      'MSPointerUp',\r\n      'MSPointerOut',\r\n      'MSPointerOver',\r\n      'MSPointerCancel',\r\n      'MSGotPointerCapture',\r\n      'MSLostPointerCapture'\r\n    ],\r\n    register: function(target) {\r\n      _dispatcher.listen(target, this.events);\r\n    },\r\n    unregister: function(target) {\r\n      _dispatcher.unlisten(target, this.events);\r\n    },\r\n    POINTER_TYPES: [\r\n      '',\r\n      'unavailable',\r\n      'touch',\r\n      'pen',\r\n      'mouse'\r\n    ],\r\n    prepareEvent: function(inEvent) {\r\n      var e = inEvent;\r\n      if (HAS_BITMAP_TYPE) {\r\n        e = _dispatcher.cloneEvent(inEvent);\r\n        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];\r\n      }\r\n      return e;\r\n    },\r\n    cleanup: function(id) {\r\n      ms__pointermap.delete(id);\r\n    },\r\n    MSPointerDown: function(inEvent) {\r\n      ms__pointermap.set(inEvent.pointerId, inEvent);\r\n      var e = this.prepareEvent(inEvent);\r\n      _dispatcher.down(e);\r\n    },\r\n    MSPointerMove: function(inEvent) {\r\n      var e = this.prepareEvent(inEvent);\r\n      _dispatcher.move(e);\r\n    },\r\n    MSPointerUp: function(inEvent) {\r\n      var e = this.prepareEvent(inEvent);\r\n      _dispatcher.up(e);\r\n      this.cleanup(inEvent.pointerId);\r\n    },\r\n    MSPointerOut: function(inEvent) {\r\n      var e = this.prepareEvent(inEvent);\r\n      _dispatcher.leaveOut(e);\r\n    },\r\n    MSPointerOver: function(inEvent) {\r\n      var e = this.prepareEvent(inEvent);\r\n      _dispatcher.enterOver(e);\r\n    },\r\n    MSPointerCancel: function(inEvent) {\r\n      var e = this.prepareEvent(inEvent);\r\n      _dispatcher.cancel(e);\r\n      this.cleanup(inEvent.pointerId);\r\n    },\r\n    MSLostPointerCapture: function(inEvent) {\r\n      var e = _dispatcher.makeEvent('lostpointercapture', inEvent);\r\n      _dispatcher.dispatchEvent(e);\r\n    },\r\n    MSGotPointerCapture: function(inEvent) {\r\n      var e = _dispatcher.makeEvent('gotpointercapture', inEvent);\r\n      _dispatcher.dispatchEvent(e);\r\n    }\r\n  };\r\n\r\n  var ms = msEvents;\r\n\r\n  function platform_events__applyPolyfill() {\r\n\r\n    // only activate if this platform does not have pointer events\r\n    if (!window.PointerEvent) {\r\n      window.PointerEvent = _PointerEvent;\r\n\r\n      if (window.navigator.msPointerEnabled) {\r\n        var tp = window.navigator.msMaxTouchPoints;\r\n        Object.defineProperty(window.navigator, 'maxTouchPoints', {\r\n          value: tp,\r\n          enumerable: true\r\n        });\r\n        _dispatcher.registerSource('ms', ms);\r\n      } else {\r\n        _dispatcher.registerSource('mouse', mouse);\r\n        if (window.ontouchstart !== undefined) {\r\n          _dispatcher.registerSource('touch', touch);\r\n        }\r\n      }\r\n\r\n      _dispatcher.register(document);\r\n    }\r\n  }\r\n\r\n  var n = window.navigator;\r\n  var s, r;\r\n  function assertDown(id) {\r\n    if (!_dispatcher.pointermap.has(id)) {\r\n      throw new Error('InvalidPointerId');\r\n    }\r\n  }\r\n  if (n.msPointerEnabled) {\r\n    s = function(pointerId) {\r\n      assertDown(pointerId);\r\n      this.msSetPointerCapture(pointerId);\r\n    };\r\n    r = function(pointerId) {\r\n      assertDown(pointerId);\r\n      this.msReleasePointerCapture(pointerId);\r\n    };\r\n  } else {\r\n    s = function setPointerCapture(pointerId) {\r\n      assertDown(pointerId);\r\n      _dispatcher.setCapture(pointerId, this);\r\n    };\r\n    r = function releasePointerCapture(pointerId) {\r\n      assertDown(pointerId);\r\n      _dispatcher.releaseCapture(pointerId, this);\r\n    };\r\n  }\r\n\r\n  function _capture__applyPolyfill() {\r\n    if (window.Element && !Element.prototype.setPointerCapture) {\r\n      Object.defineProperties(Element.prototype, {\r\n        'setPointerCapture': {\r\n          value: s\r\n        },\r\n        'releasePointerCapture': {\r\n          value: r\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  applyAttributeStyles();\r\n  platform_events__applyPolyfill();\r\n  _capture__applyPolyfill();\r\n\r\n  var pointerevents = {\r\n    dispatcher: _dispatcher,\r\n    Installer: installer,\r\n    PointerEvent: _PointerEvent,\r\n    PointerMap: _pointermap,\r\n    targetFinding: targeting\r\n  };\r\n\r\n  return pointerevents;\r\n\r\n}));\r\n\r\n(function () {\r\n\r\n/*** Variables ***/\r\n\r\n  var win = window,\r\n    doc = document,\r\n    attrProto = {\r\n      setAttribute: Element.prototype.setAttribute,\r\n      removeAttribute: Element.prototype.removeAttribute\r\n    },\r\n    hasShadow = Element.prototype.createShadowRoot,\r\n    container = doc.createElement('div'),\r\n    noop = function(){},\r\n    trueop = function(){ return true; },\r\n    regexReplaceCommas = /,/g,\r\n    regexCamelToDash = /([a-z])([A-Z])/g,\r\n    regexPseudoParens = /\\(|\\)/g,\r\n    regexPseudoCapture = /:(\\w+)\\u276A(.+?(?=\\u276B))|:(\\w+)/g,\r\n    regexDigits = /(\\d+)/g,\r\n    keypseudo = {\r\n      action: function (pseudo, event) {\r\n        return pseudo.value.match(regexDigits).indexOf(String(event.keyCode)) > -1 == (pseudo.name == 'keypass') || null;\r\n      }\r\n    },\r\n    /*\r\n      - The prefix object generated here is added to the xtag object as xtag.prefix later in the code\r\n      - Prefix provides a variety of prefix variations for the browser in which your code is running\r\n      - The 4 variations of prefix are as follows:\r\n        * prefix.dom: the correct prefix case and form when used on DOM elements/style properties\r\n        * prefix.lowercase: a lowercase version of the prefix for use in various user-code situations\r\n        * prefix.css: the lowercase, dashed version of the prefix\r\n        * prefix.js: addresses prefixed APIs present in global and non-Element contexts\r\n    */\r\n    prefix = (function () {\r\n      var keys = Object.keys(window).join();\r\n      var pre = ((keys.match(/,(ms)/) || keys.match(/,(moz)/) || keys.match(/,(O)/)) || [null, 'webkit'])[1].toLowerCase();\r\n      return {\r\n        dom: pre == 'ms' ? 'MS' : pre,\r\n        lowercase: pre,\r\n        css: '-' + pre + '-',\r\n        js: pre == 'ms' ? pre : pre.charAt(0).toUpperCase() + pre.substring(1)\r\n      };\r\n    })(),\r\n    matchSelector = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype[prefix.lowercase + 'MatchesSelector'];\r\n\r\n/*** Functions ***/\r\n\r\n// Utilities\r\n\r\n  /*\r\n    This is an enhanced typeof check for all types of objects. Where typeof would normaly return\r\n    'object' for many common DOM objects (like NodeLists and HTMLCollections).\r\n    - For example: typeOf(document.children) will correctly return 'htmlcollection'\r\n  */\r\n  var typeCache = {},\r\n      typeString = typeCache.toString,\r\n      typeRegexp = /\\s([a-zA-Z]+)/;\r\n  function typeOf(obj) {\r\n    var type = typeString.call(obj);\r\n    return typeCache[type] || (typeCache[type] = type.match(typeRegexp)[1].toLowerCase());\r\n  }\r\n\r\n  function clone(item, type){\r\n    var fn = clone[type || typeOf(item)];\r\n    return fn ? fn(item) : item;\r\n  }\r\n    clone.object = function(src){\r\n      var obj = {};\r\n      for (var key in src) obj[key] = clone(src[key]);\r\n      return obj;\r\n    };\r\n    clone.array = function(src){\r\n      var i = src.length, array = new Array(i);\r\n      while (i--) array[i] = clone(src[i]);\r\n      return array;\r\n    };\r\n\r\n  /*\r\n    The toArray() method allows for conversion of any object to a true array. For types that\r\n    cannot be converted to an array, the method returns a 1 item array containing the passed-in object.\r\n  */\r\n  var unsliceable = { 'undefined': 1, 'null': 1, 'number': 1, 'boolean': 1, 'string': 1, 'function': 1 };\r\n  function toArray(obj){\r\n    return unsliceable[typeOf(obj)] ? [obj] : Array.prototype.slice.call(obj, 0);\r\n  }\r\n\r\n// DOM\r\n\r\n  var str = '';\r\n  function query(element, selector){\r\n    return (selector || str).length ? toArray(element.querySelectorAll(selector)) : [];\r\n  }\r\n\r\n// Pseudos\r\n\r\n  function parsePseudo(fn){fn();}\r\n\r\n// Mixins\r\n\r\n  function mergeOne(source, key, current){\r\n    var type = typeOf(current);\r\n    if (type == 'object' && typeOf(source[key]) == 'object') xtag.merge(source[key], current);\r\n    else source[key] = clone(current, type);\r\n    return source;\r\n  }\r\n\r\n  function mergeMixin(tag, original, mixin, name) {\r\n    var key, keys = {};\r\n    for (var z in original) keys[z.split(':')[0]] = z;\r\n    for (z in mixin) {\r\n      key = keys[z.split(':')[0]];\r\n      if (typeof original[key] == 'function') {\r\n        if (!key.match(':mixins')) {\r\n          original[key + ':mixins'] = original[key];\r\n          delete original[key];\r\n          key = key + ':mixins';\r\n        }\r\n        original[key].__mixin__ = xtag.applyPseudos(z + (z.match(':mixins') ? '' : ':mixins'), mixin[z], tag.pseudos, original[key].__mixin__);\r\n      }\r\n      else {\r\n        original[z] = mixin[z];\r\n        delete original[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  var uniqueMixinCount = 0;\r\n  function addMixin(tag, original, mixin){\r\n    for (var z in mixin){\r\n      original[z + ':__mixin__(' + (uniqueMixinCount++) + ')'] = xtag.applyPseudos(z, mixin[z], tag.pseudos);\r\n    }\r\n  }\r\n\r\n  function resolveMixins(mixins, output){\r\n    var index = mixins.length;\r\n    while (index--){\r\n      output.unshift(mixins[index]);\r\n      if (xtag.mixins[mixins[index]].mixins) resolveMixins(xtag.mixins[mixins[index]].mixins, output);\r\n    }\r\n    return output;\r\n  }\r\n\r\n  function applyMixins(tag) {\r\n    resolveMixins(tag.mixins, []).forEach(function(name){\r\n      var mixin = xtag.mixins[name];\r\n      for (var type in mixin) {\r\n        var item = mixin[type],\r\n            original = tag[type];\r\n        if (!original) tag[type] = item;\r\n        else {\r\n          switch (type){\r\n            case 'mixins': break;\r\n            case 'events': addMixin(tag, original, item); break;\r\n            case 'accessors':\r\n            case 'prototype':\r\n              for (var z in item) {\r\n                if (!original[z]) original[z] = item[z];\r\n                else mergeMixin(tag, original[z], item[z], name);\r\n              }\r\n              break;\r\n            default: mergeMixin(tag, original, item, name);\r\n          }\r\n        }\r\n      }\r\n    });\r\n    return tag;\r\n  }\r\n\r\n// Events\r\n\r\n  function delegateAction(pseudo, event) {\r\n    var match,\r\n        target = event.target,\r\n        root = event.currentTarget;\r\n    while (!match && target && target != root) {\r\n      if (target.tagName && matchSelector.call(target, pseudo.value)) match = target;\r\n      target = target.parentNode;\r\n    }\r\n    if (!match && root.tagName && matchSelector.call(root, pseudo.value)) match = root;\r\n    return match ? pseudo.listener = pseudo.listener.bind(match) : null;\r\n  }\r\n\r\n  function touchFilter(event){\r\n    return event.button === 0;\r\n  }\r\n\r\n  function writeProperty(key, event, base, desc){\r\n    if (desc) event[key] = base[key];\r\n    else Object.defineProperty(event, key, {\r\n      writable: true,\r\n      enumerable: true,\r\n      value: base[key]\r\n    });\r\n  }\r\n\r\n  var skipProps = {};\r\n  for (var z in doc.createEvent('CustomEvent')) skipProps[z] = 1;\r\n  function inheritEvent(event, base){\r\n    var desc = Object.getOwnPropertyDescriptor(event, 'target');\r\n    for (var z in base) {\r\n      if (!skipProps[z]) writeProperty(z, event, base, desc);\r\n    }\r\n    event.baseEvent = base;\r\n  }\r\n\r\n// Accessors\r\n\r\n  function modAttr(element, attr, name, value, method){\r\n    attrProto[method].call(element, name, attr && attr.boolean ? '' : value);\r\n  }\r\n\r\n  function syncAttr(element, attr, name, value, method){\r\n    if (attr && (attr.property || attr.selector)) {\r\n      var nodes = attr.property ? [element.xtag[attr.property]] : attr.selector ? xtag.query(element, attr.selector) : [],\r\n          index = nodes.length;\r\n      while (index--) nodes[index][method](name, value);\r\n    }\r\n  }\r\n\r\n  function attachProperties(tag, prop, z, accessor, attr, name){\r\n    var key = z.split(':'), type = key[0];\r\n    if (type == 'get') {\r\n      key[0] = prop;\r\n      tag.prototype[prop].get = xtag.applyPseudos(key.join(':'), accessor[z], tag.pseudos, accessor[z]);\r\n    }\r\n    else if (type == 'set') {\r\n      key[0] = prop;\r\n      var setter = tag.prototype[prop].set = xtag.applyPseudos(key.join(':'), attr ? function(value){\r\n        var old, method = 'setAttribute';\r\n        if (attr.boolean){\r\n          value = !!value;\r\n          old = this.hasAttribute(name);\r\n          if (!value) method = 'removeAttribute';\r\n        }\r\n        else {\r\n          value = attr.validate ? attr.validate.call(this, value) : value;\r\n          old = this.getAttribute(name);\r\n        }\r\n        modAttr(this, attr, name, value, method);\r\n        accessor[z].call(this, value, old);\r\n        syncAttr(this, attr, name, value, method);\r\n      } : accessor[z] ? function(value){\r\n        accessor[z].call(this, value);\r\n      } : null, tag.pseudos, accessor[z]);\r\n\r\n      if (attr) attr.setter = accessor[z];\r\n    }\r\n    else tag.prototype[prop][z] = accessor[z];\r\n  }\r\n\r\n  function parseAccessor(tag, prop){\r\n    tag.prototype[prop] = {};\r\n    var accessor = tag.accessors[prop],\r\n        attr = accessor.attribute,\r\n        name;\r\n\r\n    if (attr) {\r\n      name = attr.name = (attr ? (attr.name || prop.replace(regexCamelToDash, '$1-$2')) : prop).toLowerCase();\r\n      attr.key = prop;\r\n      tag.attributes[name] = attr;\r\n    }\r\n\r\n    for (var z in accessor) attachProperties(tag, prop, z, accessor, attr, name);\r\n\r\n    if (attr) {\r\n      if (!tag.prototype[prop].get) {\r\n        var method = (attr.boolean ? 'has' : 'get') + 'Attribute';\r\n        tag.prototype[prop].get = function(){\r\n          return this[method](name);\r\n        };\r\n      }\r\n      if (!tag.prototype[prop].set) tag.prototype[prop].set = function(value){\r\n        value = attr.boolean ? !!value : attr.validate ? attr.validate.call(this, value) : value;\r\n        var method = attr.boolean ? (value ? 'setAttribute' : 'removeAttribute') : 'setAttribute';\r\n        modAttr(this, attr, name, value, method);\r\n        syncAttr(this, attr, name, value, method);\r\n      };\r\n    }\r\n  }\r\n\r\n  var unwrapComment = /\\/\\*!?(?:\\@preserve)?[ \\t]*(?:\\r\\n|\\n)([\\s\\S]*?)(?:\\r\\n|\\n)\\s*\\*\\//;\r\n  function parseMultiline(fn){\r\n    return typeof fn == 'function' ? unwrapComment.exec(fn.toString())[1] : fn;\r\n  }\r\n\r\n/*** X-Tag Object Definition ***/\r\n\r\n  var xtag = {\r\n    tags: {},\r\n    defaultOptions: {\r\n      pseudos: [],\r\n      mixins: [],\r\n      events: {},\r\n      methods: {},\r\n      accessors: {},\r\n      lifecycle: {},\r\n      attributes: {},\r\n      'prototype': {\r\n        xtag: {\r\n          get: function(){\r\n            return this.__xtag__ ? this.__xtag__ : (this.__xtag__ = { data: {} });\r\n          }\r\n        }\r\n      }\r\n    },\r\n    register: function (name, options) {\r\n      var _name;\r\n      if (typeof name == 'string') _name = name.toLowerCase();\r\n      else throw 'First argument must be a Custom Element string name';\r\n      xtag.tags[_name] = options || {};\r\n\r\n      var basePrototype = options.prototype;\r\n      delete options.prototype;\r\n      var tag = xtag.tags[_name].compiled = applyMixins(xtag.merge({}, xtag.defaultOptions, options));\r\n      var proto = tag.prototype;\r\n      var lifecycle = tag.lifecycle;\r\n\r\n      for (var z in tag.events) tag.events[z] = xtag.parseEvent(z, tag.events[z]);\r\n      for (z in lifecycle) lifecycle[z.split(':')[0]] = xtag.applyPseudos(z, lifecycle[z], tag.pseudos, lifecycle[z]);\r\n      for (z in tag.methods) proto[z.split(':')[0]] = { value: xtag.applyPseudos(z, tag.methods[z], tag.pseudos, tag.methods[z]), enumerable: true };\r\n      for (z in tag.accessors) parseAccessor(tag, z);\r\n\r\n      if (tag.shadow) tag.shadow = tag.shadow.nodeName ? tag.shadow : xtag.createFragment(tag.shadow);\r\n      if (tag.content) tag.content = tag.content.nodeName ? tag.content.innerHTML : parseMultiline(tag.content);\r\n      var created = lifecycle.created;\r\n      var finalized = lifecycle.finalized;\r\n      proto.createdCallback = {\r\n        enumerable: true,\r\n        value: function(){\r\n          var element = this;\r\n          if (tag.shadow && hasShadow) this.createShadowRoot().appendChild(tag.shadow.cloneNode(true));\r\n          if (tag.content) this.appendChild(document.createElement('div')).outerHTML = tag.content;\r\n          var output = created ? created.apply(this, arguments) : null;\r\n          xtag.addEvents(this, tag.events);\r\n          for (var name in tag.attributes) {\r\n            var attr = tag.attributes[name],\r\n                hasAttr = this.hasAttribute(name),\r\n                hasDefault = attr.def !== undefined;\r\n            if (hasAttr || attr.boolean || hasDefault) {\r\n              this[attr.key] = attr.boolean ? hasAttr : !hasAttr && hasDefault ? attr.def : this.getAttribute(name);\r\n            }\r\n          }\r\n          tag.pseudos.forEach(function(obj){\r\n            obj.onAdd.call(element, obj);\r\n          });\r\n          this.xtagComponentReady = true;\r\n          if (finalized) finalized.apply(this, arguments);\r\n          return output;\r\n        }\r\n      };\r\n\r\n      var inserted = lifecycle.inserted;\r\n      var removed = lifecycle.removed;\r\n      if (inserted || removed) {\r\n        proto.attachedCallback = { value: function(){\r\n          if (removed) this.xtag.__parentNode__ = this.parentNode;\r\n          if (inserted) return inserted.apply(this, arguments);\r\n        }, enumerable: true };\r\n      }\r\n      if (removed) {\r\n        proto.detachedCallback = { value: function(){\r\n          var args = toArray(arguments);\r\n          args.unshift(this.xtag.__parentNode__);\r\n          var output = removed.apply(this, args);\r\n          delete this.xtag.__parentNode__;\r\n          return output;\r\n        }, enumerable: true };\r\n      }\r\n      if (lifecycle.attributeChanged) proto.attributeChangedCallback = { value: lifecycle.attributeChanged, enumerable: true };\r\n\r\n      proto.setAttribute = {\r\n        writable: true,\r\n        enumerable: true,\r\n        value: function (name, value){\r\n          var old;\r\n          var _name = name.toLowerCase();\r\n          var attr = tag.attributes[_name];\r\n          if (attr) {\r\n            old = this.getAttribute(_name);\r\n            value = attr.boolean ? '' : attr.validate ? attr.validate.call(this, value) : value;\r\n          }\r\n          modAttr(this, attr, _name, value, 'setAttribute');\r\n          if (attr) {\r\n            if (attr.setter) attr.setter.call(this, attr.boolean ? true : value, old);\r\n            syncAttr(this, attr, _name, value, 'setAttribute');\r\n          }\r\n        }\r\n      };\r\n\r\n      proto.removeAttribute = {\r\n        writable: true,\r\n        enumerable: true,\r\n        value: function (name){\r\n          var _name = name.toLowerCase();\r\n          var attr = tag.attributes[_name];\r\n          var old = this.hasAttribute(_name);\r\n          modAttr(this, attr, _name, '', 'removeAttribute');\r\n          if (attr) {\r\n            if (attr.setter) attr.setter.call(this, attr.boolean ? false : undefined, old);\r\n            syncAttr(this, attr, _name, '', 'removeAttribute');\r\n          }\r\n        }\r\n      };\r\n\r\n      var definition = {};\r\n      var instance = basePrototype instanceof win.HTMLElement;\r\n      var extended = tag['extends'] && (definition['extends'] = tag['extends']);\r\n\r\n      if (basePrototype) Object.getOwnPropertyNames(basePrototype).forEach(function(z){\r\n        var prop = proto[z];\r\n        var desc = instance ? Object.getOwnPropertyDescriptor(basePrototype, z) : basePrototype[z];\r\n        if (prop) {\r\n          for (var y in desc) {\r\n            if (typeof desc[y] == 'function' && prop[y]) prop[y] = xtag.wrap(desc[y], prop[y]);\r\n            else prop[y] = desc[y];\r\n          }\r\n        }\r\n        proto[z] = prop || desc;\r\n      });\r\n\r\n      definition['prototype'] = Object.create(\r\n        extended ? Object.create(doc.createElement(extended).constructor).prototype : win.HTMLElement.prototype,\r\n        proto\r\n      );\r\n\r\n      return doc.registerElement(_name, definition);\r\n    },\r\n\r\n    /* Exposed Variables */\r\n\r\n    mixins: {},\r\n    prefix: prefix,\r\n    captureEvents: { focus: 1, blur: 1, scroll: 1, DOMMouseScroll: 1 },\r\n    customEvents: {\r\n      animationstart: {\r\n        attach: [prefix.dom + 'AnimationStart']\r\n      },\r\n      animationend: {\r\n        attach: [prefix.dom + 'AnimationEnd']\r\n      },\r\n      transitionend: {\r\n        attach: [prefix.dom + 'TransitionEnd']\r\n      },\r\n      move: {\r\n        attach: ['pointermove']\r\n      },\r\n      enter: {\r\n        attach: ['pointerenter']\r\n      },\r\n      leave: {\r\n        attach: ['pointerleave']\r\n      },\r\n      scrollwheel: {\r\n        attach: ['DOMMouseScroll', 'mousewheel'],\r\n        condition: function(event){\r\n          event.delta = event.wheelDelta ? event.wheelDelta / 40 : Math.round(event.detail / 3.5 * -1);\r\n          return true;\r\n        }\r\n      },\r\n      tap: {\r\n        attach: ['pointerdown', 'pointerup'],\r\n        condition: function(event, custom){\r\n          if (event.type == 'pointerdown') {\r\n            custom.startX = event.clientX;\r\n            custom.startY = event.clientY;\r\n          }\r\n          else if (event.button === 0 &&\r\n                   Math.abs(custom.startX - event.clientX) < 10 &&\r\n                   Math.abs(custom.startY - event.clientY) < 10) return true;\r\n        }\r\n      },\r\n      tapstart: {\r\n        attach: ['pointerdown'],\r\n        condition: touchFilter\r\n      },\r\n      tapend: {\r\n        attach: ['pointerup'],\r\n        condition: touchFilter\r\n      },\r\n      tapmove: {\r\n        attach: ['pointerdown'],\r\n        condition: function(event, custom){\r\n          if (event.type == 'pointerdown') {\r\n            var listener = custom.listener.bind(this);\r\n            if (!custom.tapmoveListeners) custom.tapmoveListeners = xtag.addEvents(document, {\r\n              pointermove: listener,\r\n              pointerup: listener,\r\n              pointercancel: listener\r\n            });\r\n          }\r\n          else if (event.type == 'pointerup' || event.type == 'pointercancel') {\r\n            xtag.removeEvents(document, custom.tapmoveListeners);\r\n            custom.tapmoveListeners = null;\r\n          }\r\n          return true;\r\n        }\r\n      },\r\n      taphold: {\r\n        attach: ['pointerdown', 'pointerup'],\r\n        condition: function(event, custom){\r\n          if (event.type == 'pointerdown') {\r\n            (custom.pointers = custom.pointers || {})[event.pointerId] = setTimeout(\r\n              xtag.fireEvent.bind(null, this, 'taphold'),\r\n              custom.duration || 1000\r\n            );\r\n          }\r\n          else if (event.type == 'pointerup') {\r\n            if (custom.pointers) {\r\n              clearTimeout(custom.pointers[event.pointerId]);\r\n              delete custom.pointers[event.pointerId];\r\n            }\r\n          }\r\n          else return true;\r\n        }\r\n      }\r\n    },\r\n    pseudos: {\r\n      __mixin__: {},\r\n      mixins: {\r\n        onCompiled: function(fn, pseudo){\r\n          var mixin = pseudo.source && pseudo.source.__mixin__ || pseudo.source;\r\n          if (mixin) switch (pseudo.value) {\r\n            case null: case '': case 'before': return function(){\r\n              mixin.apply(this, arguments);\r\n              return fn.apply(this, arguments);\r\n            };\r\n            case 'after': return function(){\r\n              var returns = fn.apply(this, arguments);\r\n              mixin.apply(this, arguments);\r\n              return returns;\r\n            };\r\n            case 'none': return fn;\r\n          }\r\n          else return fn;\r\n        }\r\n      },\r\n      keypass: keypseudo,\r\n      keyfail: keypseudo,\r\n      delegate: {\r\n        action: delegateAction\r\n      },\r\n      preventable: {\r\n        action: function (pseudo, event) {\r\n          return !event.defaultPrevented;\r\n        }\r\n      },\r\n      duration: {\r\n        onAdd: function(pseudo){\r\n          pseudo.source.duration = Number(pseudo.value);\r\n        }\r\n      },\r\n      capture: {\r\n        onCompiled: function(fn, pseudo){\r\n          if (pseudo.source) pseudo.source.capture = true;\r\n        }\r\n      }\r\n    },\r\n\r\n    /* UTILITIES */\r\n\r\n    clone: clone,\r\n    typeOf: typeOf,\r\n    toArray: toArray,\r\n\r\n    wrap: function (original, fn) {\r\n      return function(){\r\n        var output = original.apply(this, arguments);\r\n        fn.apply(this, arguments);\r\n        return output;\r\n      };\r\n    },\r\n    /*\r\n      Recursively merges one object with another. The first argument is the destination object,\r\n      all other objects passed in as arguments are merged from right to left, conflicts are overwritten\r\n    */\r\n    merge: function(source, k, v){\r\n      if (typeOf(k) == 'string') return mergeOne(source, k, v);\r\n      for (var i = 1, l = arguments.length; i < l; i++){\r\n        var object = arguments[i];\r\n        for (var key in object) mergeOne(source, key, object[key]);\r\n      }\r\n      return source;\r\n    },\r\n\r\n    /*\r\n      ----- This should be simplified! -----\r\n      Generates a random ID string\r\n    */\r\n    uid: function(){\r\n      return Math.random().toString(36).substr(2,10);\r\n    },\r\n\r\n    /* DOM */\r\n\r\n    query: query,\r\n\r\n    skipTransition: function(element, fn, bind){\r\n      var prop = prefix.js + 'TransitionProperty';\r\n      element.style[prop] = element.style.transitionProperty = 'none';\r\n      var callback = fn ? fn.call(bind || element) : null;\r\n      return xtag.skipFrame(function(){\r\n        element.style[prop] = element.style.transitionProperty = '';\r\n        if (callback) callback.call(bind || element);\r\n      });\r\n    },\r\n\r\n    requestFrame: (function(){\r\n      var raf = win.requestAnimationFrame ||\r\n                win[prefix.lowercase + 'RequestAnimationFrame'] ||\r\n                function(fn){ return win.setTimeout(fn, 20); };\r\n      return function(fn){ return raf(fn); };\r\n    })(),\r\n\r\n    cancelFrame: (function(){\r\n      var cancel = win.cancelAnimationFrame ||\r\n                   win[prefix.lowercase + 'CancelAnimationFrame'] ||\r\n                   win.clearTimeout;\r\n      return function(id){ return cancel(id); };\r\n    })(),\r\n\r\n    skipFrame: function(fn){\r\n      var id = xtag.requestFrame(function(){ id = xtag.requestFrame(fn); });\r\n      return id;\r\n    },\r\n\r\n    matchSelector: function (element, selector) {\r\n      return matchSelector.call(element, selector);\r\n    },\r\n\r\n    set: function (element, method, value) {\r\n      element[method] = value;\r\n      if (window.CustomElements) CustomElements.upgradeAll(element);\r\n    },\r\n\r\n    innerHTML: function(el, html){\r\n      xtag.set(el, 'innerHTML', html);\r\n    },\r\n\r\n    hasClass: function (element, klass) {\r\n      return element.className.split(' ').indexOf(klass.trim())>-1;\r\n    },\r\n\r\n    addClass: function (element, klass) {\r\n      var list = element.className.trim().split(' ');\r\n      klass.trim().split(' ').forEach(function (name) {\r\n        if (!~list.indexOf(name)) list.push(name);\r\n      });\r\n      element.className = list.join(' ').trim();\r\n      return element;\r\n    },\r\n\r\n    removeClass: function (element, klass) {\r\n      var classes = klass.trim().split(' ');\r\n      element.className = element.className.trim().split(' ').filter(function (name) {\r\n        return name && !~classes.indexOf(name);\r\n      }).join(' ');\r\n      return element;\r\n    },\r\n\r\n    toggleClass: function (element, klass) {\r\n      return xtag[xtag.hasClass(element, klass) ? 'removeClass' : 'addClass'].call(null, element, klass);\r\n    },\r\n\r\n    /*\r\n      Runs a query on only the children of an element\r\n    */\r\n    queryChildren: function (element, selector) {\r\n      var id = element.id,\r\n          attr = '#' + (element.id = id || 'x_' + xtag.uid()) + ' > ',\r\n          parent = element.parentNode || !container.appendChild(element);\r\n      selector = attr + (selector + '').replace(regexReplaceCommas, ',' + attr);\r\n      var result = element.parentNode.querySelectorAll(selector);\r\n      if (!id) element.removeAttribute('id');\r\n      if (!parent) container.removeChild(element);\r\n      return toArray(result);\r\n    },\r\n\r\n    /*\r\n      Creates a document fragment with the content passed in - content can be\r\n      a string of HTML, an element, or an array/collection of elements\r\n    */\r\n    createFragment: function(content) {\r\n      var template = document.createElement('template');\r\n      if (content) {\r\n        if (content.nodeName) toArray(arguments).forEach(function(e){\r\n          template.content.appendChild(e);\r\n        });\r\n        else template.innerHTML = parseMultiline(content);\r\n      }\r\n      return document.importNode(template.content, true);\r\n    },\r\n\r\n    /*\r\n      Removes an element from the DOM for more performant node manipulation. The element\r\n      is placed back into the DOM at the place it was taken from.\r\n    */\r\n    manipulate: function(element, fn){\r\n      var next = element.nextSibling,\r\n          parent = element.parentNode,\r\n          returned = fn.call(element) || element;\r\n      if (next) parent.insertBefore(returned, next);\r\n      else parent.appendChild(returned);\r\n    },\r\n\r\n    /* PSEUDOS */\r\n\r\n    applyPseudos: function(key, fn, target, source) {\r\n      var listener = fn,\r\n          pseudos = {};\r\n      if (key.match(':')) {\r\n        var matches = [],\r\n            valueFlag = 0;\r\n        key.replace(regexPseudoParens, function(match){\r\n          if (match == '(') return ++valueFlag == 1 ? '\\u276A' : '(';\r\n          return !--valueFlag ? '\\u276B' : ')';\r\n        }).replace(regexPseudoCapture, function(z, name, value, solo){\r\n          matches.push([name || solo, value]);\r\n        });\r\n        var i = matches.length;\r\n        while (i--) parsePseudo(function(){\r\n          var name = matches[i][0],\r\n              value = matches[i][1];\r\n          if (!xtag.pseudos[name]) throw \"pseudo not found: \" + name + \" \" + value;\r\n          value = (value === '' || typeof value == 'undefined') ? null : value;\r\n          var pseudo = pseudos[i] = Object.create(xtag.pseudos[name]);\r\n          pseudo.key = key;\r\n          pseudo.name = name;\r\n          pseudo.value = value;\r\n          pseudo['arguments'] = (value || '').split(',');\r\n          pseudo.action = pseudo.action || trueop;\r\n          pseudo.source = source;\r\n          pseudo.onAdd = pseudo.onAdd || noop;\r\n          pseudo.onRemove = pseudo.onRemove || noop;\r\n          var original = pseudo.listener = listener;\r\n          listener = function(){\r\n            var output = pseudo.action.apply(this, [pseudo].concat(toArray(arguments)));\r\n            if (output === null || output === false) return output;\r\n            output = pseudo.listener.apply(this, arguments);\r\n            pseudo.listener = original;\r\n            return output;\r\n          };\r\n          if (!target) pseudo.onAdd.call(fn, pseudo);\r\n          else target.push(pseudo);\r\n        });\r\n      }\r\n      for (var z in pseudos) {\r\n        if (pseudos[z].onCompiled) listener = pseudos[z].onCompiled(listener, pseudos[z]) || listener;\r\n      }\r\n      return listener;\r\n    },\r\n\r\n    removePseudos: function(target, pseudos){\r\n      pseudos.forEach(function(obj){\r\n        obj.onRemove.call(target, obj);\r\n      });\r\n    },\r\n\r\n  /*** Events ***/\r\n\r\n    parseEvent: function(type, fn) {\r\n      var pseudos = type.split(':'),\r\n          key = pseudos.shift(),\r\n          custom = xtag.customEvents[key],\r\n          event = xtag.merge({\r\n            type: key,\r\n            stack: noop,\r\n            condition: trueop,\r\n            capture: xtag.captureEvents[key],\r\n            attach: [],\r\n            _attach: [],\r\n            pseudos: '',\r\n            _pseudos: [],\r\n            onAdd: noop,\r\n            onRemove: noop\r\n          }, custom || {});\r\n      event.attach = toArray(event.base || event.attach);\r\n      event.chain = key + (event.pseudos.length ? ':' + event.pseudos : '') + (pseudos.length ? ':' + pseudos.join(':') : '');\r\n      var stack = xtag.applyPseudos(event.chain, fn, event._pseudos, event);\r\n      event.stack = function(e){\r\n        e.currentTarget = e.currentTarget || this;\r\n        var detail = e.detail || {};\r\n        if (!detail.__stack__) return stack.apply(this, arguments);\r\n        else if (detail.__stack__ == stack) {\r\n          e.stopPropagation();\r\n          e.cancelBubble = true;\r\n          return stack.apply(this, arguments);\r\n        }\r\n      };\r\n      event.listener = function(e){\r\n        var args = toArray(arguments),\r\n            output = event.condition.apply(this, args.concat([event]));\r\n        if (!output) return output;\r\n        // The second condition in this IF is to address the following Blink regression: https://code.google.com/p/chromium/issues/detail?id=367537\r\n        // Remove this when affected browser builds with this regression fall below 5% marketshare\r\n        if (e.type != key && (e.baseEvent && e.type != e.baseEvent.type)) {\r\n          xtag.fireEvent(e.target, key, {\r\n            baseEvent: e,\r\n            detail: output !== true && (output.__stack__ = stack) ? output : { __stack__: stack }\r\n          });\r\n        }\r\n        else return event.stack.apply(this, args);\r\n      };\r\n      event.attach.forEach(function(name) {\r\n        event._attach.push(xtag.parseEvent(name, event.listener));\r\n      });\r\n      return event;\r\n    },\r\n\r\n    addEvent: function (element, type, fn, capture) {\r\n      var event = typeof fn == 'function' ? xtag.parseEvent(type, fn) : fn;\r\n      event._pseudos.forEach(function(obj){\r\n        obj.onAdd.call(element, obj);\r\n      });\r\n      event._attach.forEach(function(obj) {\r\n        xtag.addEvent(element, obj.type, obj);\r\n      });\r\n      event.onAdd.call(element, event, event.listener);\r\n      element.addEventListener(event.type, event.stack, capture || event.capture);\r\n      return event;\r\n    },\r\n\r\n    addEvents: function (element, obj) {\r\n      var events = {};\r\n      for (var z in obj) {\r\n        events[z] = xtag.addEvent(element, z, obj[z]);\r\n      }\r\n      return events;\r\n    },\r\n\r\n    removeEvent: function (element, type, event) {\r\n      event = event || type;\r\n      event.onRemove.call(element, event, event.listener);\r\n      xtag.removePseudos(element, event._pseudos);\r\n      event._attach.forEach(function(obj) {\r\n        xtag.removeEvent(element, obj);\r\n      });\r\n      element.removeEventListener(event.type, event.stack);\r\n    },\r\n\r\n    removeEvents: function(element, obj){\r\n      for (var z in obj) xtag.removeEvent(element, obj[z]);\r\n    },\r\n\r\n    fireEvent: function(element, type, options){\r\n      var event = doc.createEvent('CustomEvent');\r\n      options = options || {};\r\n      event.initCustomEvent(type,\r\n        options.bubbles !== false,\r\n        options.cancelable !== false,\r\n        options.detail\r\n      );\r\n      if (options.baseEvent) inheritEvent(event, options.baseEvent);\r\n      element.dispatchEvent(event);\r\n    }\r\n\r\n  };\r\n\r\n  if (typeof define === 'function' && define.amd) define(xtag);\r\n  else if (typeof module !== 'undefined' && module.exports) module.exports = xtag;\r\n  else win.xtag = xtag;\r\n\r\n  doc.addEventListener('WebComponentsReady', function(){\r\n    xtag.fireEvent(doc.body, 'DOMComponentsLoaded');\r\n  });\r\n\r\n})();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/x-tag/dist/x-tag-core.js\n// module id = 4\n// module chunks = 0","import xtag from 'xtag'\r\n\r\nexport default function Mixin(name, options = {}) {\r\n\tif (!xtag.mixins[name])\r\n\t\txtag.mixins[name] = options\r\n\treturn name\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixin.js","import xtag from 'xtag'\r\n\r\nexport default function Pseudo(name, {action = null, onAdd = null, onRemove = null, onCompiled = null}) {\r\n\tif (!xtag.pseudos[name])\r\n\t\txtag.pseudos[name] = {action, onAdd, onRemove, onCompiled}\r\n\treturn name\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/pseudo.js","import xtag from 'xtag'\r\n\r\nexport default function WebComponent(name, options = {}) {\r\n\treturn xtag.tags[name] || xtag.register(name, options)\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/web-component.js"],"sourceRoot":""}